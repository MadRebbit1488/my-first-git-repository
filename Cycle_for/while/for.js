//цикл FOR / FOR..OF / FOR..IN / BREAK / CONTINUE / LABEL(мітка)
/* Виконує код доки умова = true. перебір елементів
Синтаксис:
for (ініціалізація;умова;крок)

Цикли потрібні щоб виконувати одну і туж дію багато разів: пройтись по вьому масиву і збільшити величину кожного його елемента на одиницю.

Після for в () спочатку оголошується певна змінна, потім умова яка має повернути true або false . Третій блок вказує що потрібно зробити з вихідною змінною-ствердженням, для того щоб ітеруватись. Тобто після кожної ітерації буде виконуватись саме цей шматок кода i++(це теж саме що (i = i + 1)). кожного разу по завершенні циклу "i" збільшується на одиницю і це робиться доти доки ось тут i < 10 не буде 10 або більше.*/


//
//Потрібно вивести баланс декілька разів
for (let i = 1; i < 10; i=i+1) {
  console.log(`Наш баланс ${i}$`); // 9 разів був виведений баланс  'Наш баланс 1$' до ' Наш баланс 9$'
}
//В даному виразі початкове значення "1", кожного разу в кінці цикла ми збільшуємо його не одиницю і зупиняємось коли i < 10


//
//Потрібно вивести в консоль список задач
const tasks = ['Задача 1', 'Задача 2'];

for (let i = 0; i < tasks.length; i++) { //tasks.length-означає,що        ітерація буде відбуватись до довжини масиву
  console.log(tasks[i]); //  Задача 1   Задача 2
}
//Даний цикл дасть змогу проходитись по масиву від початку до кінця

______
/* 
Якщо при ініціалізації циклу не використовувати let/const, то коли буде оголошено цикл з такоюж змінною, то значення змінної зміниться і перший цикл перевіривши вказану умову закінчиться швидше
*/

function A() {
  for (i = 1; i <= 3; i++){
    console.log('A : ' +i);
    B();
  }
}

function B () {
  for (i = 1; i <= 3; i++){
    console.log('B : ' +i);
  }
}

A();
/* 
1.Ітерація -  A : 1
2.Ітерація -  B : 1
3.Ітерація -  B : 2
4.Ітерація -  B : 3
*/

_______________________________________________________________________
/* 
Якщо оголошувати змінну за допомогою var, то вона буде доступна і поза циклом. На відмінну віл let(достувно в межах циклу) i const(зупиняє цикл після першої ітерації).
Але в середині циклу можна використовувати зарання оголошену змінну або використовувати існуючю і тоді вона буде доступна поза циклом
*/
for(var a=1;a<3;a++){
alert('змінна a в циклі: '+a);
}
alert('змінна a за циклом оголошена за допомогою var: '+a);
___________________________________________________________________________
for (let i = 0; i < 3; i++) {
  console.log(i); //0, 1, 2
}

for (let x = 1; x < 10; x = x + 2) {
  console.log(x); //1, 3, 5, 7, 9
}

for (let i = 0, x = 1; i < 3; i++, x+=2) {
  console.log('i: '+i+' x: '+x); 
}
/* 
1.  i: 0 x: 1
2.  i: 1 x: 3
3.  i: 2 x: 5
 */

for (let i = 1; i < 9; i++) {
    console.log(i); // від 1 до 6
    if (i > 5) {
        break;
    }
}
___________________________________________________________________________
// Можна пропустити початок в циклі
let i = 0;
for (; i < 3; i++) {
  console.log(i); //0, 1, 2
}
//Можна пропустити крок і тоді цикл буде аналогічний while
let a = 0;
for (;a < 3;) {
  console.log(a++); //0, 1, 2
}
//Можна пропустити всі елементи в дужках ( ; ; ) і тоді цикл буде безкінечним.
___________________________________________________________________________
//Оголошуючи іншицй цикл в середині циклу, вони мають мати різні змінні. Інікше перша змінна перезапишеться 
for (let i = 1; i < 5; i++) {
  console.log(`Цикл 1 - ${i}`);
  for (let j = 1; j < 5; j++) {
    console.log(`Цикл 2 - ${j}`);
  }
}
/* Виведеться цикл 1, потім пройдуть всі ітерації циклу 2, потім ітерація циклу 1 і всі ітерації циклу 2. Внутрішній цикл буде виконуватись частіше ніж зовнішній, тому що він зупиняється при кожній новій ітерації зовнішнього циклу.
Вкладені цикли можна зустріти при роботі з двувимірними масивами, або об'ємами інформації де присутнє подвійне вкладення .*/
___________________________________________________________________________
//Масив в якому 1-й і 2-й елементи масиви
const tasks2 = [[1, 'Задача 1'], [2, 'Задача 2']];
//Потрібно написати цикл який буде виводити інформацію про кожен із цих елементів

for (let i = 0; i < tasks2.length; i++) { // Так цикл пройдеться по елментах зовнішнього масиву
  for (let j = 0; j < tasks2[i].length; j++) { //Друга ітерація ройдеться по внутрішньому масиву
    console.log(tasks2[i][j]);
  }
}

___________________________________________________________________________
//BREAK / CONTINUE / мітка LABEL
//Дають можливість управляти поведінкою цикла
//Break - зупиняє цикл. Корисний коди потрібно дійти до якогось елементу обо знайти його і повністю припинити цикл. Зручно для тих випадків коли умова, по якій потрібно перерватись, знаходиться не на початку або в кінці, а посередині або в декількох місцях циклу

//Continue - дозволяє переходити до наступної ітерації, якщо умова все ще true. Зручний коли потрібно щось пропустити і не виконувати якийсь код при певній умові

const tasks1 = ['Задача 1', 'Задача 2', 'Задача 3'];

for (let i = 0; i < tasks1.length; i++) { 
  if (tasks1[i] === 'Задача 2') { //Пропускаємо другу задачю
    continue;
  }
  console.log(tasks1[i]); //  Задача 1   Задача 3
}

___ 
for (let i = 0; i < tasks1.length; i++) { 
  if (tasks1[i] === 'Задача 2') { 
    break;
  }
  console.log(tasks1[i]); //  Задача 1  
}
// Дійшовши до другої задачі виконується break і це означає,що припиняються всі цикли, виконання умови завершується і ми з циклу виходимо
___
for (let i = 0; i < 7; i++) {
  if (i == 5)
  continue;
  console.log(i); // 0, 1, 2, 3, 4, 6
}

___
for (let i =0 ; i < 5; i++) {
  if (i == 3) break;
  console.log(i); //0, 1, 2
}
___
//Підраховуємо сумму відних чисел до тих пір, поки користувач їх вводить
let sum = 0;
while (true) {
    let value = +prompt ('Введіть число', '');
    if (!value) break;
    sum += value;
}
console.log('Сума:' +sum); // 5+8+9+5 = Сума:27
//Директива break повністю припиняє виконання циклу і передає управляння на рядок за його тілом, тобто console.log
___
//Виводимо тільки непарні числа
for (let i = 0; i < 10; i++) {
    //Якщо true пропустити іншу частину тіла циклу
    if(i%2==0) continue;
    console.log('Виводимо: '+i); //Виводимо: 1, Виводимо: 3, Виводимо: 5, Виводимо: 7, Виводимо: 9
}
___
//Виводимо тільки парні числа
for (let i = 0; i < 10; i++) {
    if(i%2!==0) continue;
    console.log('Виводимо: '+i); //Виводимо: 0, Виводимо: 2, Виводимо: 4, Виводимо: 6, Виводимо: 8
}
___
//break/continue не можна використовувати справа від "?", так як вони не являються виразами. Це викличе помилку
//(i > 5) ? console.log(i) : continue; // Error

___________________________________________________________________________
//Мітки для break/continue
/* Мітка має вигляд ідентифікатора з двокрапкою (:) перед циклом
Синтаксис:
labelName: for () {}
Виклик break <labelName> в циклі шукає найближчий зовнішній цикл з такою міткою і переходить в його кінець
*/

//Запитуємо за допомогою prompt координати (i, j) з (0,0) до (2,2)
outher: for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
        let input = prompt(`Значення на координатах (${i},${j})`, '');
        //Якщо порожній рядок або "Відміна", то вийти з обох циклів
        if (!input) break outher;
        //Зробити щось із значенням
    } 
}
console.log('Готово!');
/* Викликом break outher буде розіваний зовнішній цикл до мітки з іменем outher. Таким чином управління перейде до рядка console.log('Готово!'); 
Директиву continue також можна використовувати з міткою, тоді управління перейде на наступну ітерацію цикла з міткою.
Мітка не дає змоги передавати управляння в довільне місце коду.

break label; // не стрибає до мітки нижче
label: for (...)

Директива break має знаходитись в середині блока коду:

label: {
    break label; //Працює
}

*/
___________________________________________________________________________
// FOR..OF

//i < arr.length вираховується при кожній ітерації, не підходить для складних масивів
const arr = [1, 4, 8, 7];

for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]); //1, 4, 8, 7
}

//let оголошує не індекс масиву по якому буде проходити ітерація
//element of arr - значає що кожного разу ітеруючись по масиву буде братись елемент масиву

//for..of дозволяє коротко ітеруватись і завдяки ньому не потрібно використовувати індекс
//Перебирає масив по елементам і дозволяє виконувати додаткові операції
for (let element of arr) {
  console.log(element); //1, 4, 8, 7
}

//FOR..IN
//Перебирає масив по індексу
//Не потрібно: робити перевірку не довжину, збільшувати перебір індекса
for (let index in arr) {
  console.log(index); //0, 1, 2, 3
  console.log(arr[index]); //1, 4, 8, 7
}

___
const arr1 = [1, 2, 3];
for (const el in arr1) {
    console.log(el); //1, 2, 3
}
___
//Виводимо всі властивості об'єкта

let user = {
    name: 'John',
    age: 30,
    isAdmin: true,
};

for (let key in user) {
    console.log(key); //name, age , isAdmin
    console.log(user[key]); // John, 30, true
}
___________________________________________________________________________




