/* ЗМІСТ
*ВВЕДЕННЯ В БРАУЗЕРНІ ПОДІЇ
  *Обробники подій
    -Використання HTML-атрибута
    -Використання властивостей DOM-об'єкта
  -Доступ до елемента через this
  -addEventListener
  -Обробники подій які можна назначити тільки через addEventListener
  -Об'єкт події
  -handleEvent - об'єкт-обробник
  
*Сплив і занурення
  *Спливання
    -event.target
  *ЗУПИНКА СПЛИВАННЯ
    -event.stopPropagation()
    -event.stoplmmediatePropagation()
  *ЗАНУРЕННЯ (перехват)
    -event.eventPhase

*ДЕЛЕГУВАННЯ ПОДІЙ
  *Приклад Делегування: діаграмма Ба-Гуа
  *Використання делегування: дія в розмітці
  *Прийьом проектування <<Поведінки>>
        -Приклад: Поведінка 'Лічильник'
        -Приклад: Поведінка 'Перемикач'(toggler)

*ДІЇ БРАУЗЕРА ЗА ЗАМОВЧУВАННЯМ  
  -Відміна дії браузера
    *event.preventDefault() - стандартний метод для відміни дій браузера
    *Витікання подій один із одного
    *Опція "passive" для обробника 
    *passive: true для addEventListener - сигналізує браузеру, що обробник не збирається виконувати preventDefault()
    *event.defaultPrevented - властивість встановлено в true, якщо дія за замовчуванням була попереджена і false якщо ні


  */


/* 
*ВВЕДЕННЯ В БРАУЗЕРНІ ПОДІЇ
!Подія - це сигнал браузера про те, що щось відбулось. 
Всі DOM-вузли подають такі сигнали(хочя події бувають не тільки в DOM)

Список найчастіше використовуваних подій:
? Події миші:
  *cllick - відбувається якщо клікнути на елемент лівою кнопкою миші
  *contextmenu - відбувається коли клікнули на елемент правою кнопкою миші
  *mouseover / mouseout - коли миша наводиться на / покидає елемент 
  *mousedown / mouseup - коли натиснули / віджали кнопку миші на елементі
  *mousemove - при русі миші

? Події на елементах управління
  *submit - користувач відправив форму <form>
  *focus - користувач фокусується на елементі, наприклад натискає <input>

? Клавіатурні події:
  *keydown / keyup - коли користувач натискає / відпускає клавішу
  
? Події документа: 
  *DOMContentLoaded - коли HTML завантажений і опрацьований, DOM документа повністю побудований і доступний

? CSS events:
  *transitionend - коли CSS-анімація завершена








*Обробники подій
Події можна назначити обробника, це ф-ція яка спрацює як тільки подія відбулася
Є декілька способів назначити події обробника:
  -Використання HTML-атрибута: onclick="..."
  -Використання властивостей DOM-об'єкта: elem.onclick = function.
  -Спеціальні методи: для додавання elem.addEventListener(event, handler[, phase]), для видалення removeEventListener 

    *Використання HTML-атрибута
    Використовується рідко, так як використання JS в HTML не доречно
    Обробник може бути назначений прямо в розмітці, який називається on<Подія>
    Наприклад щоб назначити обробника подій click на елементі input, можн використати атрибут onclick

    ?<input value="Натисни мене" onclick="alert('Клік')" type="button">
    При клікі мишою на кнопці виконується код вказаний в атрибуті onclick. 

    ?Приклад: По кліку запускається ф-ція countRabbits()
    <script>
    function countRabbits(){
      for(let i=1; i<=3; i++){
        console.log('Кролик номер ' + i);
      }
    }
    </script>
    <input type="button" onclick="countRabbits()" value="Рахувати кроликів!">


    *Використання властивостей DOM-об'єкта
    Можна назначити обробника, використовуючи властивість DOM-елемента on<Подія>
    ?Приклад: elem.onclick
    <input id="elem" type="button" value="Натисни мене!">
    <script>
      elem.onclick = function() {
        console.log('Дякую!')
      };
    </script>

    Якщо обробник заданий через атрибут, то браузер читає HTML-розмітку, створює нову ф-цію із вмісту атрибута і записує у властивість
    Цей метод аналогічний попередньому.

    ?Обробник завжди зберігається в властивості DOM-об'єкта, а атрибут - лише один із способів його ініціалізації.
    ?Приклад: Тільки HTML
    <input type="button" onclick="alert('Клик!')" value="Кнопка">

    ?Приклад: HTML + JS
    <input type="button" id="button" value="Кнопка">
    <script>
      button.onclick = function () {
          console.log('Дякую!')
        };
    </script>
    Обидва приклади працюють однаково

    ?Так як у елемента DOM може бути лише одна властивість з іменем onclick, то назначити більше одного обробника так неможна
    ?Приклад: JS перезапише обробник із атрибута
    <input type="button" id="elem" onclick="console.log('Було')" value="Натисни мене">
    <script>
      elem.onclick = function(){ //Перезапише існуючий обробник
        console.log('Стало')  //Виведеться тільки це
      }
    </script>

    Обробником можна назначити вже існуючу ф-цію
    function sayThanks() {
      alert('Спасибо!');
    }
    elem.onclick = sayThanks;

    Приклад: Одна частина коду при клікі на кнопку робить її підсвіченою, а інша - видавати повідомлення. Але так як DOM може моти тільки один обробник, то другий замінить першим. Фундаментальний недостаток


*Доступ до елемента через this
Всередині обробника подій this посилається на поточний елемент, тобто на той на якому висить обробник
?Приклад: button виводить свій вміст використовуючи this.innerHTML
<button onclick="alert(this.innerHTML)">Натисни мене</button>


!Не потрібно використовувати setAttribute  для обробників
Приклад:  Такий виклик працювати не буде
При натисканні на body будуть помилки, атрибути завжди рядки і ф-ція стане рядком
document.body.setAttribute('onclick', function() { alert(1) }); 
    


*addEventListener / removeEventListener
Альтернативний спосіб назначення обробників. Вони вільні від недоліку 1 обробника елементів DOM
?Синтаксис додавання обробника:
?element.addEventListener(event, handler, [options])
    -event - ім'я події, наприклад "click"
    -handler - посилання на ф-цію обробника
    -options - додатковий об'єкт із властивостями
      -once: якщо true, тоді обробник буде автоматично видалений після виконання
      -capture: фаза, на якій повинен спрацювати обробник
        Історично склалось що options може бути false/true, це теж саме що {capture: false/true}
      -passive: якщо true, то вказує, що обробник ніколи не викличе preventDefault()
?Синтаксис видалення обробника:
?element.removeEventListener(event, handler, [options]); 
?Для видалення потрібна та ф-ція яка була назначена 
Приклад:  Неправильно
elem.addEventListener( "click" , () => alert('Дякую!'));
elem.removeEventListener( "click", () => alert('Дякую!'));  
Обробник не буде видалений, так як передана не та ж сама ф-ція, а інша з однаковим кодом
?Приклад: Правильно
function handler() {
  alert( 'Спасибо!' );
}
input.addEventListener("click", handler);
input.removeEventListener("click", handler);
!Якщо ф-ція обробник не зберегти, її не можна буде видалити
Немає метода, який дозволить отримати із елемента обробник подій, назначений addEventListener

Метод addEventListener дозволяє додати декілька обробників на одну подію одного елемента
?Приклад:
<input id="elem" type="button" value="Натисни мене">
<script>
  function handler(){
    alert('Дякую')
  }
  function handler1() {
    alert('Дякую щє раз')
  }
  elem.onclick = () => alert('Привіт');
  elem.addEventListener('click', handler);  //Дякую
  elem.addEventListener('click', handler1); //Дякую щє раз
</script>
Можна назначити одночасно обробники і через DOM-властивості і через addEventListener

*Обробники подій які можна назначити тільки через addEventListener виключення: transitionend і DOMContentLoaded
DOMContentLoaded, яка спрацьовує коли завершено завантаження і побудова DOM документа
?Приклад:
Так не спрацює
  document.onDOMContentLoader = function(){
    console.log('DOM побудований')
  }
Так спрацює
  document.addEventListener('DOMContentLoaded', function(){
    console.log('DOM побудований')
  })
    


*Об'єкт події
addEventListener  підтримує об'єкти і класи в якості обробки подій В такому випадку викликається метод об'єкта handleEvent
Щоб добре опрацювати подію потірбні деталі того що відбулось. Не просто 'клік' чи 'натискання клавіші', а також координати вказівника миші, яка клавіша натиснута і тд.
Коли відбувається подія, браузер створює об'єкт події, записує в нього деталі і передає його в якості аргумента ф-ції-обробнику
?Приклад: Отримання координат миші із об'єкта події
<input type="button" value="Натисни мене" id="elem">
<script>
  elem.onclick = function(event){
    вивести тип події, елемент і координати кліка
    console.log(event.type + ' на ' + event.currentTarget);//click на [object HTMLInputElement]
    console.log('Координати: ' + event.clientX + ':' + event.clientY);//Координати: 71:15
  }
</script> 

  *event - властивості об'єкта
    -event.type - тип події, приклад "click"
    -event.currentTarget - елемент на якому спрацював обробник. Значення  зазвичай таке ж як і в this, яле якщо обробник стрілкова ф-ція або за допомогою bind прив'язаний інший об'єкт в якості this, то ми можемо отримати елемент із event.currentTarget
    -event.clientX / event.clientY - координати курсора в момент кліка відносно вікна, для подій миші

?При назначенні обробника в HTML можна використовувати об'єкт event ось так:
<input type="button" onclick="console.log(event.type)" value="Тип події"> //click
Це можливо тому, що коли браузер із атрибута створює ф-цію оброник, то вона виглядає як function(event) { alert(event.type) }. Тобто її перший аршумент називається "event", а тіло взято із атрибута
<input type="button" onclick="addEventListener" id="elem" value="Кнопка">
<script>
  elem.addEventListener('click', function (event) { 
    console.log(event.type) }); //click
</script>



*handleEvent - об'єкт-обробник
Обробником можна назначати не тілки ф-цію, а й об'єкт за допомогою addEventListener. В даному випадку, коли відбуваєтьяс подія, викликається метод об'єкта handleEvent
?Приклад:
<button id="elem">Натисни мене</button>
<script>
  elem.addEventListener('click', {
    handleEvent(event){
      console.log(event.type + ' на ' + event.currentTarget);//

    }
  });
</script>
Якщо addEventListener  отримує об'єкт в якості обробника, він викликає object.handleEvent(event) коли відбувається подія

?Приклад: Також можна використати клас
<button id="elem">Натисни мене</button>
<script>
  class Menu {
    handleEvent(event){
      switch(event.type){
        case 'mousedown':
          elem.innerHTML = 'Натиснута кнопка миші';
          break;
        case 'mouseup':
          elem.innerHTML += '...і віджата';
          break;
      }
    }
  }
  let menu = new Menu();
  elem.addEventListener('mousedown', menu);
  elem.addEventListener('mouseup', menu);
</script>

Тут один і тойже об'єкт обробляє обидві події. Потрібно явно назначити обидів обробника подій через addEventListener. Тоді об'єкт menu  буде отримувати події mousedown і mouseup, але не інші, не назначені типи подій

Метод handleEvent  не обов'язково має робити все сам. Він може викликати інші методи які підходять під обробку конкретних типів подій
?Приклад: Обробка подій розділена по методах, що полегшує підтримку кода
<button id="elem">Натисни мене</button>
<script>
  class Menu {
    handleEvent(event) {
      //mousedown -> onMousedown
      let method = 'on' + event.type[0].toUpperCase() + event.type.slice(1);
      this[method](event);
    }
    onMousedown() {
      elem.innerHTML = "Кнопка мыши нажата";
    }
    onMouseup() {
      elem.innerHTML += "...и отжата.";
    }
  }
  let menu = new Menu();
  elem.addEventListener('mousedown', menu);
  elem.addEventListener('mouseup', menu);
</script>     */






























___________________________________________________________________________
//!Сплив і занурення
/* 
-Спливання
    -event.target
-ЗУПИНКА СПЛИВАННЯ
    -event.stopPropagation()
    -event.stoplmmediatePropagation()
-ЗАНУРЕННЯ (перехват)
    -event.eventPhase*/
/* 
?Приклад: Обробник для <div> спрацює, якщо клікнути по <em>
<div onclick="console.log('Обробник!')">
  <em>Якщо клікнути на <code>EM</code>, спрацює обробник на <code>DIV</code></em>
</div>


*СПЛИВАННЯ
Принцип простий
?Коли на елементі відбувається подія, обробник спочатку спрацьовує на ньому, потім на його батьку, потім вищє і так далі, вверх по ланцьожку предків

?Приклад: Є 3 вкладених елемента FORM > DIV > P з обробником на кожному:
<style>
    body *{
      margin: 10px;
      border: 1px solid blue;
    }
  </style>
  <form onclick="alert('form')">FORM  //form
    <div onclick="alert('div')">DIV  //div->form
      <p onclick="alert('p')">P</p> //p->div->form
    </div>
  </form>
Клік по внутрішньому <p> викличе обробник onclick спочатку на собі потім на div потім на form і так далі вверх по ланцужку до самого document

?Спливають майже всі події, але є виключення
Подія focus не спливає


*event.target 
Завжди можна дізнатись на якому конкретному елементі відбулась подія
Найглибший елемент, який викликає подію, називається цільовим елементом і він доступний через event.target
Відмінність від this(=event.currentTarget)
    -event.target - це цільовий елемент, на якому відбулась подія, в процесі спливання він незмінюється
    -this - це поточний елемент, до якого дійшло спливання, на ньому зараз виконується обробник

Якщо стоїть тільки один обробник form.onclick, то він зловить всі кліки всередині форми. Де б не був клік - він спливе до елемента form на якому спрацює обробник
При цьому всередині обробника form.onclick:
    - this (=event.currentTarget) завжди буде елемент <form>, так як обробник спрацював на ньому
    - event.target буде містити посилання на конкретний елемент всередині форми, на якому відбувся клік
    Клік покаже обидва: і <code>event.target</code>, і <code>this</code> для порівняння:

<form id="form">FORM 
    <div>DIV 
      <p>P</p>
    </div>
  </form>
<script>
  form.onclick = function(event){
    event.target.style.backgroundColor = 'yellow';
  
    setTimeout(()=>{
      console.log('target = ' + event.target.tagName + ', this = ' + this.tagName);
      event.target.style.backgroundColor = '';
    }, 300);
  }
</script>
target = P, this = FORM
target = DIV, this = FORM
target = FORM, this = FORM

event.target і this - один і тойже елемент коли клік відбувається безпосередньо на самоме елементі <form>, а не на його піделементі

*ЗУПИНКА СПЛИВАННЯ
Спливання іде з цільового елемента прямо вгору. За замовчуванням подія буде спливати до елемента  <html>, а потім до об'єкта document, а іноді навіть до window, викликаючи всі обробників на своєму шляху.
Але будь який проміжний обробник може вирішити, що подія повністю оброблена, і зупинити її.
Для цього потрібно викликати метод 
*event.stopPropagation() - зупиняє пересування обробників далі, але на поточному елементі всі обробники будуть викликані, якщо в елемента є декілька обробників на одну подію. 

?Приклад: При клікі на <button> обробник body.onclick не спрацює
<body onclick="alert(`Сюди спливання не дійде`)">
<button onclick="event.stopPropagation()">Клік</button>

*event.stoplmmediatePropagation() - повністю зупиняє обробку подій на поточному елементі і запобігає спливанню

Не варто зупиняти спливання без необхідності. Спливання це зручно. Так як зачасту зупинка спливання через event.stopPropagation() має свої особливості які з часом можуть стати проблемою:
  1. Ми робимо вкладене меню. Кожне підменю опрацьовує кліки на своїх елементах і робить для них stopPropagation, щоб не спливало зовнішнє меню
  2.Потім коли потірбно відслідкувати всі кліки в вікні для якогось функціоналу (статистики де клікають люди). ДЛя цього зазвичай використовується document.addEventListener('click'…) щоб відловлювати всі кліки.
  3. Аналітика не буде працювати над областю де кліки зупиняються stopPropagation

Зазвичай немає необхідності зупиняти спливання. Але коли це потрібно, то задачю варто вирішувати по іншому. Наприклад за допомогою створення своєї унікальної події. Також можна записувати службову інфо в об'єкт event в одному обробнику, а читати в іншому. Таким чином можна повідомляти обробникам на батьківських елементах інфо про те, що подія вже була якось оброблена


*ЗАНУРЕННЯ (перехват)
Дуже рідко викорисовується в реальному коді, але інколи може бути корисна.
?Стандарт DOM Event описує 3 фози проходження подій:
  1. Фаза занурення(capturing phase) - подія спочатку іде зверху до низу
  2. Фаза мети(target phase) - подія досягла цільового елемента
  3. Фаза спливання(bubbling stage) - подія починає спливати 

Тобто при клікі на елемент, подія спуститься по ланцюжку батьківських елементів вниз до елемента, досягне мети, а потім повернеться на верх викликаючи на шляху обробників
Видимою є лише фаза спливання, все інше як правило не використовується і проодить непомітно.
Обробники додані через on<event>-властивість або через HTML-атрибути або через addEventListener(event, handler) з 2 аргументами, нічього не знають про фазу занурення, а працюють тільки на 2 і 3 фазах.

Щоб зловити подію на стадії занурення, потрібно використовувати третій аргумент capture
elem.addEventListener(...,{capture: true})
або просто true як скорочення для {capture: true}
elem.addEventListener(..., true)
Існує два варіанта значення опції capture:
  1. Якщо аргумент false (за замовчуванням), то подія буде перехоплена при спливанні
  2. Якщо аргумент true, то подія буде перехоплена при зануренні

  Другу фазу ( фазу мети) неможна опрацювати окремо, при її досяганні викликаються всі обробники: і на спливання і на занурення
  ?Приклад: Занурення і спливання
  <style>
    body * {
      margin: 10px;
      border: 1px solid blue;
    }
  </style>
    <form >FORM
    <div>DIV
      <p>P</p>
    </div>
  </form>
  <script>
    for(let elem of document.querySelectorAll('*')){
      elem.addEventListener('click', e=>console.log(`Занурення: ${elem.tagName}`), true);
      elem.addEventListener('click', e=>console.log(`Спливання: ${elem.tagName}`))
    }
  </script>
  Клік на 'Р'
  Занурення:  HTML ->  BODY -> FORM -> DIV -> P
  Спливання: P -> DIV -> FORM -> BODY -> HTML

Тут обробник навішується на кожен елемент в документі, щоб побачити в якому порядку вони викликаються по мірі проходження події
1.  HTML ->  BODY -> FORM -> DIV фаза занурення 
2. Р - фаза мети
3. DIV -> FORM -> BODY -> HTML фаза спливання

*event.eventPhase - властивість яка містить номер фази, на якій подія була перехоплена. Використовується рідко

?Якщо додати обробник ось так addEventListener(..., true), то потрібно передати теж значення аргумента capture в removeEventListener(..., true), коли знімається обробник

На кожній фазі різні обробники на одному елеменіт спрацьовують в тому порядку  в якому вони встановлені
<button id="elem">Click</button>
<script>
  elem.addEventListener('click', e=> alert(1)); <-спрацьовує перед наступним
  elem.addEventListener("click", e => alert(2));
</script>

Кожен обробник має доступ до властивостей події event:
    - event.target - найглибший елемент, на якому відбулася подія
    - event.currentTarget (=this) - елемент, на якому в даний момент спрацював обробник
    - event.eventPhase - на якій фазі він спрацював
*/























___________________________________________________________________________
//!ДЕЛЕГУВАННЯ ПОДІЙ
/* 
    -Приклад Делегування: діаграмма Ба-Гуа
    -Використання делегування: дія в розмітці
    -Прийьом проектування <<Поведінки>>
        -Приклад: Поведінка 'Лічильник'
        -Приклад: Поведінка 'Перемикач'(toggler)


Спливання і перехват подій дозволяють реалізувати один із найважливіших прийомів розробки - делегування
Ідея в тому, що якщо є багато елементів, події на яких потрібно опрацювати схожим чином, то замість того щоб назначати кожному обробник, ми ставимо одного обробника на їх спільного предка.
Із event.target можна отримати цільовий елемент, щоб зрозуміти на якому нащадку відбулася подія і опрацювати її.

Алгоритм делегування:
  1. Вішає обробник на контейнер
  2. В обробнику перевіряється вихідний елмент event.target
  3. Якщо подія відбулася всередині потрібного елемента, то обробляємо його

Для чього використовується:
  1. Полегшує процес ініціалізації і економить пам'ять, так як не потрібно вішати багато обробників
  2.  Менше кода: при додаванні/видаленні елементів не потрібно ставити або знімати обробники
  3. Зручна зміна DOM: можна масово додавати або видаляти елементи шляхом зміни innerHTML і йому подібних

Обмеження:
  1. Подія має спливати. Деякі події цього не роблять. Також низькорівневі обробники не мають викликати event.stopPropagation()
  2. Створює додаткове навантаження на браузер, адже обробник запускається коли подія відбувається в будь-якому місці контейнера, не обов'язково на елементах котрі потрібні. Але навантаження не наскільки велике, щоб його потрібно було брати до уваги

?Приклад Делегування: діаграмма Ба-Гуа
Частина шаблону
<table id="bagua-table">
  <tr>
    <th colspan="3">Квадрат<em>Bagua</em>: Направление, Элемент, Цвет, Значение</th>
  </tr>
  <tr>
    <td class="nw"><strong>Северо-Запад</strong>
      <br>Металл
      <br>Серебро
      <br>Старейшины
    </td>
    <td class="n"><strong>Север</strong>
      <br>Вода
      <br>Синий
      <br>Перемены
    </td>

Задача реалізувати підсвітку квадратів <td> при кліку
Замість того щоб назначати обробник onclick для кожного квадрату <td>, можна повісити один обробник на елемент <table>. Він буде використовувати event.target, щоб отримати елемент, на якому відбулася подія і підсвітить його
Код:
  let table = document.getElementById('bagua-table');
    let selectedTd;

    table.onclick = function (event) {
      let target = event.target;   <-Де був клік
      while (target != this) {
        if (target.tagName == 'TD') { <- Пропускаємо якщо не на TD
          highlight(target);  <- Підсвітити TD
          return;
        }
        target = target.parentNode;
      }
    }

    function highlight(node) {
      if (selectedTd) {   <- Прибрати існуючу підсвітку, якщо є 
        selectedTd.classList.remove('highlight');
      }
      selectedTd = node;
      selectedTd.classList.add('highlight');  <- Підсвітити новий td
    } 

Даному коду к-ть квадратів байдужа, він буде стабільно працювати якщо додавати або видаляти <td>.
Але так клік може бути не на тегу <td>, а всередині нього , наприклад на тегу <strong>, то він стане значенням event.target. Тому всередині обробника table.onclick потрібно по event.target розібратись, чи був клік всередині <td> чи ні. ТОму кращє змінити код:

table.onclick = function(event) {
  let td = event.target.closest('td'); 
  if (!td) return; 
  if (!table.contains(td)) return; 
  highlight(td); 
};

Тепер:
1. Метод elem.closest(selector) повертає найближчього предка, відповідаючього селектору. В даному випадку потрібен <td>, який знаходиться вищє по дереву вихідного елемента.
2. Якщо event.target не міститься всередині елемента <td>, то виклик поверне null і нічього не відбудеться.
3. event.target може містити елемент <td>, який знаходиться поза таблицьою. В такому випадку потрібно перевірити, дійсно <td> з таблиці. Якщо це так то він підсвічуюється


*Використання делегування: дія в розмітці
?Приклад: Потрібно меню із різними кнопками: «Зберегти (save)», «Завантажити (load)», «Пошук (search)» і тд. і в них будуть відповідні об'єкти з методами save, load, search.
Можна додати один обробник для всього меню і атрибути data-action для кожної кнопки в відповідності до метода який вони викликають.
<button data-action="save">Натисни, щоб зберегти</button>
Обробник буде зчитувати вміст атрибута і виконувати метод^

<div id="menu">
    <button data-action="save">Зберегти</button>
    <button data-action="load">Завантаажити</button>
    <button data-action="search">Пошук</button>
</div>

<script>
  class Menu{
    constructor(elem){
      this._elem = elem;
      elem.onclick = this.onClick.bind(this);
    }
    save(){
      console.log('Зберегти');
    }
    load(){
      console.log('Завантаажити');
    }
    search(){
      console.log('Пошук');
    }
    onClick(event){
      let action = event.target.dataset.action;
      if(action){
        this[action]();
      }
    }
  }
  new Menu(menu);
</script>

this.onClick прив'язується до контексту поточного об'єкта this. Так як в іншому випадку this буде посилатись на DOM-елемент (elem), а не на об'єкт Menu, і this[action] буде не тим чим потрібно.

Делегування дає можливість не писати код для обробника кожної кнопки. Достатньо просто створити один метод і помістити його в розмітку.
Структура HTML стає більш гнучкішою. Так як можна додавати/видаляти елементи в будь який час.
Також можна використовувати класи .action-save, .action-load, але підхід з використанням data-action більш семантичний. І їх можна використовувати для стилізації в правилах CSS


*Прийьом проектування <<Поведінки>>
Делегування можна використовувати для додавання спеціального елемента <<Поведінки>> (behavior), декларативно задаючи хитрі обробники установкою спеціальних HTML-атрибутів і класів.
Прийом проектування <<Поведінки>> складається із 2 частин:
  1. Елементу ставиться користувацький атрибут, який описує його поведінку
  2. За допомогою делегування ставится обробник на документ, який ловить всі кліки(або інші події) і якщо елемент має потрібний атрибут, робить відпоавідну дію.

  !Приклад: Поведінка 'Лічильник'
  Тут HTML-атрибут data-counter дадає кнопкам поведінку 'збільшити значення при клікі'

  Лічильник: <input type="button" value="1" data-counter>
  Щє лічильник: <input type="button" value="2" data-counter>
  <script>
    document.addEventListener('click', function(event){
      if(event.target.dataset.counter != undefined){
        event.target.value++;
      }
    });
  </script>

Якщо натиснути кнопку - значення збільшиться .
Елементів з атрибутом data-counter маже бути скільки завгодно і нові можуть додаватись в HTML в будь-який момент. За допомогою делегування фактично додається новий 'псевдостандартний' атрибут в HTML, який додає елементу нову поведінку

?Завжди потрібно використовувати addEventListener  для обробників на рівні документа, а не document.on<подія>. Так як в випадку останнього можуть виникнути конфлікти: нові обробники будуть перезаписувати вже існуючі


!Приклад: Поведінка 'Перемикач'(toggler)
При клікі на елемент з атрибутом data-toggle-id буде приховуватись/показуватись елемент з заданим id

<button data-toggle-id="subscribe-mail">
  Показати форму підписки
</button>
<form id="subscribe-mail" hidden>
  Ваша пошта: <input type="email">
</form>
<script>
  document.addEventListener('click', function(event){
    let id = event.target.dataset.toggleId;
    if(!id) return;
    let elem = document.getElementById(id);
    elem.hidden = !elem.hidden;
  })
</script>

Тепер щоб додати показати/приховати будь-якому елементу не обов'язково писати JS для кожного елемента, можна просто написати атрибут data-toggle-id і використовувати поведінку. Обробник на рівні документа зробить це можливим для елемента на будь-якому місці сторінки.
Можна комбінувати декілька варіантів поведінки на одному елементі.
Шаблон поведінки може слугувати альтернативою для фрагментів JS-кода в верстці
*/


























___________________________________________________________________________
//! ДІЇ БРАУЗЕРА ЗА ЗАМОВЧУВАННЯМ
/* 
-Відміна дії браузера
    *event.preventDefault() - стандартний метод для відміни дій браузера
    *Витікання подій один із одного
    *Опція "passive" для обробника 
    *passive: true для addEventListener - сигналізує браузеру, що обробник не збирається виконувати preventDefault()
    *event.defaultPrevented - властивість встановлено в true, якщо дія за замовчуванням була попереджена і false якщо ні


Події несуть за собою дії браузера:
- Клік по посиланню ініціює перехід на новий URL
- Натискання кнопки відправити в формі - відсилання форми на сервер
- Затискання кнопки миші над текстом і її рух в такому стані - ініціює виділення 
Але обробкою подій за допомогою JS можна відмінити стандартні дії браузера, якщо вони не потрібні

Дій браузера за замовчуванням багато: 
  -  mousedown  - починає виділяти текст якщо рухати мишкою
  -  click на <input type="checkbox"> - ставить або прибирає галочку в input
  - submit - при натисканні на <input type="submit"> або при натисканні Enter в формі данні відправляються на сервер
  - keydown  - при натисканні клавіші в полі введення з'явиться символ
  - contextmenu - при правому клікі показує контекстне меню браузера
  і тдю

*Відміна дії браузера
Є два способи:
  1. Основний спосіб - скористатись об'єктом event.
      *event.preventDefault() - стандартний метод для відміни дій браузера за замовчкуванням або return false
  2. Якщо обробник назначений через on<подія> ( не через addEventListener), то можна повернути false  із обробника

  ?Приклад: При клікі на силку перехід не відбудеться
  <a href="https://web.kamihq.com/" onclick="return false">Посилання1</a>
  <a href="https://web.kamihq.com/" onclick="event.preventDefault()">Посилання2</a>

  ?Приклад: Меню для сайта
  ?В HTML розміткі всі елементи меню являються не кнопками ,а посиланнями, тобто тегами <a>. Так як в цьому є певні переваги
    - Поєднання 'правий клік' + 'відкрити в новому вікні'. Якщо використовувати <button> або <span>, дане поєднання працювати не буде
    -Пошукові движки переходять по посиланням <a href="..."> при індексації

  <style>
  .menu li {
  display: inline-block;
  margin: 0;
}
.menu > li a {
  display: inline-block;
  margin: 0 2px;
  outline: none;
  text-align: center;
  text-decoration: none;
  font: 14px/100% sans-serif;
  padding: .5em 2em .55em;
  text-shadow: 0 1px 1px rgba(0, 0, 0, .3);
  border-radius: .5em;
  box-shadow: 0 1px 2px rgba(0, 0, 0, .2);
  color: #d9eef7;
  border: solid 1px #0076a3;
  background: #0095cd;
}
.menu > li:hover a {
  text-decoration: none;
  background: #007ead;
}
  </style>
  <ul id="menu" class="menu">
    <li><a href="html">HTML</a></li>
    <li><a href="javascript">JavaScript</a></li>
    <li><a href="css">CSS</a></li>
  </ul>
  
  <script>
    menu.onclick = function(event){
      if(event.target.nodeName != 'A') return;
      let href = event.target.getAttribute('href');
      console.log(href)
      return false;
    }
  </script>
  ?return false; відміняє дії браузера, тобто перехід на посилання

*Деякі події витікають один із одного і якщо відмінити першу подію, то наступні не відбудуться
Подія mousedown  для поля <input> приводить до фокусуванню на ньому і запускає подію focus. Якщо відмінити подію mousedown, то фокусування не відбудеться.
?Приклад: Якщо натиснути на перший  <input> - відбувається подія focus. Якщо на 2 ,то події focus не буде тому що відміненно стандартну дію mousedown
<style>
    #popa{
      cursor: pointer;
    }
</style>
<input value="Фокус працює" onfocus="this.value=''">
<input id="popa" onmousedown="return false" onfocus="this.value=''" value="Тикни в мене пальчиком">

Фокусування на другому елементі все щє можливе, якщо використовувати інший спосіб. Натисканням клавіші TAB можна перейти від першого поля вводу до другого. Але тільки не через клік миші на елемент

*Опція "passive" для обробника 

*passive: true для addEventListener - сигналізує браузеру, що обробник не збирається виконувати preventDefault(), тобто дія за замовчуванням не буде відмінятись. Необов'язкова опція
Є подія, така як touchmove на мобільних пристороях ( коли користувач переміщує палець по екрану) яка за замовчуванням розпочинає прокрутку, але цю дію можна відмінити використовуючи preventDefault() в обробнику.
Тому коли браузер знаходить таку подію, він повинен для початку запустити всі обробники і після, якщо preventDefault() ніде не викликається, він може починати прокрутку. Це може викликати затримки в користувацькому інтерфейсі
Опція passive: true повідомляє браузеру, що обробник не збирається відміняти прокрутку. Тоді браузер розпочинає її негайно, забезпечуючи максимально плавний інтерфейс, паралельно обробляючи події

?Для Firefox, Chrome опція passive за замовчуванням true для таких подій як touchstart і touchmove


*event.defaultPrevented - повертає булеве значення, інформуюче про те чи був викликаний event.preventDefault() в поточному обробнику подій
Якщо подія за замовчуванням відмінена, значення event.defaultPrevented стає true, інакше false
Інколи можна використовувати для зупинки спливання замість event.stopPropagation(). Щоб дати сигнал іншим обробникам, що подія оброблена



?Приклад: За замовчуванням браузер при події contextmenu (клік правою кнопкою миші) показу контекстне меню із стандартними опціями. Можна відмінити дію за замовчуванням і показати своє меню:

<button>Правий клік викликає контекстне меню браузера</button>
  <button oncontextmenu="alert('Інше меню'); return false">
    Правий клік викликає інше меню
</button>

?Можна реалізувати контекстне меню для всього документа
  <p>Правий клік тут викликає контекстне меню документа </p>
  <button id="elem">Правий клік тут викликає контекстне меню кнопки</button>
    <script>
      elem.oncontextmenu = function(event){
        event.preventDefault();
        alert('Контекстне меню кнопки')
      }
      document.oncontextmenu = function(event){
        event.preventDefault();
        alert('Контекстне меню документа')
      }
    </script>

Проблема в тому, що при клікі на button id="elem, ми отримуємо два меню, контекстне меню кнопки і документа ( подія спливає вверх).
Щоб зупинити спливання при обробці правого кліка на кнопку, потрібно викликати event.stopPropagation()

  <p>Правий клік тут викликає контекстне меню документа </p>
  <button id="elem">Правий клік тут викликає контекстне меню кнопки</button>
    <script>
      elem.oncontextmenu = function(event){
        event.preventDefault();
        event.stopPropagation();
        alert('Контекстне меню кнопки')
      }
      document.oncontextmenu = function(event){
        event.preventDefault();
        alert('Контекстне меню документа')
      }
    </script>

Тепер контекстне меню для кнопки працює так як потрібно. Але тепер заборонений доступ до інфо про праві кліки для будь якого зовнішнього коду.

Альтернативним рішенням буде перевірити в обробнику document, чи була відмінена дія за замовчуванням. Якщо так, то подія була оброблена і нам не потрібно на нього реагувати.

  <p>Правий клік тут викликає контекстне меню документа </p>
  <button id="elem">Правий клік тут викликає контекстне меню кнопки</button>
    <script>
      elem.oncontextmenu = function(event){
        event.preventDefault();
        
        alert('Контекстне меню кнопки')
      }
      document.oncontextmenu = function(event){
        if (event.defaultPrevented) return; Перевіряє чи відмінена подія за замовчуванням в обробнику. Якщо так, то ф-ція нічього не повертає, якщо ні виконується код далі. 
        event.preventDefault(); Блокує сьандартну дію контекстного меню
        alert('Контекстне меню документа')
      }
    </script>

Тепер все працює без втрат. Якщо є вкладені елементи і кожен із них має контекстне меню, код буде працювати так же. Потрібно просто переконатись, що перевіряться event.defaultPrevented в кожному обробнику contextmenuю

event.stopPropagation() і event.preventDefault()(return false) - це дві різні ф-ції, які ніяк одна з одною не пов'язані

Існує альтернативний шлях реалізації вкладених контекстних меню. Потрібен глобальний об'єкт із обробником document.oncontextmenu і методами, які дозволяють зберігати в ньому інші обробники.
Об'єкт буде перехоплювати будь який клік правою кнопкою миші, передивлятись збережені обробники і запускати відповідні.
Але при цьому кожен фрагмент коду, якому потрібне контекстне меню, повинен знати про цей об'єкт і використовувати його замість власного обробника contextmenu

*/




























___________________________________________________________________________
//! ГЕНЕРАЦІЯ КОРИСТУВАЦЬКИХ ПОДІЙ
/*
Події можна назначати не тільки обробником, а і генерувати їх з JS.
Щоб згенерувати подію із кода, спочатку потрібно створити об'єкт події
Користувацьку події можуть бути використані для створення графічних компонентів.
Приклад: Корінний елемент меню  реалізований за допомогою JS, може генерувати події які відносяться до даного меню: open (меню відкрито), select (вибраний пункт меню). А інший код може слухати ці події і дізнаватись, що відбувається з меню.
Можна генерувати не тільки нові, придумані події але і вбудовані: click, mousedown і тд. Це може бути користано для автоматичного тестування.

Генерація вбудованих подій корисна в таких випадках:
  - Як явних і грубий хак, щоб змусити працювати сторонні бібліотеки, в яких не передбачені інші засоби взаємодії
  - Або для автоматичного тестування, щоб скриптом 'натиснути на кнопку' і подивитись, чи відбулась потрібна подія.



*Конструктор EVENT
Вбудовані класи для подій формують ієрархію аналогічно класам DOM-елементів. ЇЇ основою являється вбудований клас Event.

Події вбудованого класу Event можна створити так:
? let event = new Event(type[, options]);
Де:
  - type - тип події, рядок, наприклад onclick або інший придуманий         my-event
  - options  - об'єкт з трьома нербов'язковими властивостями
        - bubbles: true/false - якщо true, то подія спливає
        - cancelable: true/false - якщо true, тоді можна відмінити дію за замовчуванням. Тобто якщо ми хочемо, щоб event.preventDefault() працював
        - composed: true/false - якщо true, тоді подія буде випливати назовні за межі  Shadow DOM
  За замовчуванням, всі три властивості установлені в false: {bubbles: false, cancelable: false, composed: false}.


* Метод dispatchEvent - відправляє подію в спільну систему події
Після створення об'єкту події, його потрібно запустити на елементі, викликавши метод elem.dispatchEvent(event).
При цьому подія спрацьовує на рівні з браузером, тобто на нього відреагують звичайні браузерні обробники.
Якщо при створенні указати пропор bubbles, то подія буде спливати 

?Приклад: Обробник onclick на кнопці спрацює сам по собі, подію згенерує скрипт
<button id="elem" onclick="alert('Клік');">Автоклік</button>
  <script>
    let event = new Event('click'); 
    elem.dispatchEvent(event);
  </script>
  В коді створюється нова подія з ім'ям click за допомогою конструктора Event. Ця подія буде симулювати клік на елементі, на якому викликається метод dispatchEvent. В даному випадку метод викликається на elem, тобто на кнопці.
  Таким чином, код автоматично викликає подію click на кнопці, без необхідності фізичного кліку

?Приклад: при клікі на document вискакує повідомлення
<script>
  document.onclick = function(){
    alert('BYM');
  }
  let event = document.createEvent("MouseEvent");
  document.dispatchEvent(event)
</script>
- - - - - - - - - - - - - - - - - - - - - - - 
<script>
  document.onclick = function(){
    alert('BYM');
  }
  let event = new Event('click');
  document.dispatchEvent(event);
</script>


  *event.isTrusted - властивість приймає значення true(якщо користувач клікнув сам)  для події, яка була ініційована діями користувача і false ( якщо подія ініційована кодом)  якщо подія була створена або змінена скриптом, або за допомогою dispatchEvent
  ТОбто метод відрізняє справжню подію (реальне натискання ) від згенерованого коду.
  Це властивість об'єкта Event, доступна тільки для читання.
  Синтаксис: let bool = event.isTrusted;
  Приклад:
    if (e.isTrusted) {
      The event is trusted. 
    } else {
      The event is not trusted. 
    }

  


?Приклад: Можна створити спливаючю подію з ім'ям hello і спіймати її на document. Для цього потрібно встановити прапор bubbles в true:
<h1 id="elem">Привітусі</h1>
  <script>
    ловим на document
    document.addEventListener('hello', function(event){
      console.log('Привітусі від '+ event.target.tagName); Привітусі від H1
    });

    Запускаємо подію на елементі
    let event = new Event('hello', {bubbles: true});
    elem.dispatchEvent(event);
    Обробник на document спрацює і виведе повідомлення
  </script>
  
  Для власних подій потрібно використовувати саме addEventListener, так як on<подія> - властивості існують тільки для вбудованих подій, табто document.onhello не спрацює
  Механізм спливання ідентичний як для вбудованих подій так для придуманих користувацьких. Також однакова робота фаз сливання і занурення.


*Специфічні конструктори: MouseEvent, KeyboardEvent, і інші
Для деяких типів подій є свої специфічні конструктори.
Список констпукторів для різних подій користувацьокого інтерфейсу:
Специфікація UI Event:
    - UIEvent
    - FocusEvent
    - MouseEvent
    - WheelEvent
    - KeyboardEvetn
    - CustomEvent - генерація нових подій

Їх потрібно використовувати замість new Event якщо потрібно створити такі події: new MouseEvent("click")
Специфічний конструктор дозволяє вказати стандартні властивості для даного типу подій.
?Приклад: clientX/clientY для подій миші
    let event = new MouseEvent('click', {
      bubbles: true,
      cancelable: true,
      clientX: 100,
      clientY: 100
    });
    console.log(event.clientX);

Із звичайним конструктором Event,  подія миші буде проігнорована.
Щоб це працювало із Event потрібно властивість записати в об'єкт окремо, після створення, ось так event.clientX=100.

*CustomEvent - генерує нові користувацькі події
Технічно абсолютно ідентичний Event  за винятком однієї деталі.
У другого аргумента-об'єкта є додаткова властивість detail в якому можна вказувати інфо для передачі в подію. Після чього всі обробники зможуть отримати до  неї доступ через event.detail

<h1 id="elem">Helo</h1>
  <script>
    Додатвкова інфо приходить в обробник разом з подією
    elem.addEventListener('hello', function(event){
      alert(event.detail.name);
    });
    elem.dispatchEvent(new CustomEvent('hello', {
      detail: {name: 'Жолудь'}
    }));
  </script>

  В звичайний конструктор new Event можна записувати будь-які властивості, але CustomEvent  надає спеціальне поле detail щоб запобігти появі конфліктів з іншими властивостями події. Властивість detail може містити будь які дані.


*event.preventDefault()
Для багатьох браузерних подій є дії за замовчуванням.
Для нових подій браузерних дій немає, але код який генерує таку подію, може передбачити якісь свої дії після події.
Виклик evene.preventDefaul() це можливість обробнику події повідомити в сгенерувавший подію код, що ці дії потрібно відмінити.
Тоді виклик elem.dispatchEvent(event) поверне false. І код який згенерував подію дізнається що продовжувати не потрібно.
?Приклад: Ховається кролик
В коді є кролик #rabbit і ф-ція hide(), яка при виклику генерує на ньому подію 'hide', яка увідомляє що кролик збирається сховатись.
Будь який обробник може дізнатись про це підписавшись на подію hide через rabbit.addEventListener('hide',...) і за бражанням відмінити дію за замовчуванням через event.preventDefault(). Тоді кролик зникне

  <pre id="rabbit">
      |\   /|
      \ |_| /
      / . . \
     =\_ Y _/=
       {>o<}
  </pre>
  <button onclick="hide()">Hide()</button>

  <script>
    hide() буде викликаниц при клікі на кнопку
    function hide(){
      let event = new CustomEvent('hide', {
        cancelable: true, // без нього preventDefault не спрацює
      });
      if(!rabbit.dispatchEvent(event)){
        console.log('Дія відмінена обробником');
      } else {
        rabbit.hidden = true;
      }
    }
    rabbit.addEventListener('hide', function(event){
      if(confirm('Викликати preventDefault?')){
        event.preventDefault();
      }
    });
  </script>

  ? Подія повинна мати прапор  cancelable: true, інакше виклик event.preventDefault() буде проігноровано.

  *Вкладенні події обробляються синхронно.
  Зазвичай події обробляються асинхронно. Тобто якщо браузер обробляє подію onclick  і в процесі цього відбудеться якесь нова подія, то він чекає поки закінчиться обробка onclick .
  Винятком є читуація коли подія ініційована із обробника іншої події.
  Тоді управління спочатку переходить в обробник вкладеної події і вже після цього повертається назад.
  ?Приклад: Подія menu-open обробляється синхронно під час обробки onclick

<button id="menu">Menu</button>
<script>
  menu.onclick = function(){
    alert(101);


    menu.dispatchEvent(new CustomEvent('menu-open', {
      bubbles: true,
    }));
    alert(2);
  };
  document.addEventListener('menu-open', () => alert('Вкладена подія'))
</script>

Порядок вивода: 1 -> Вкладена подія -> 2
Вкладена подія menu-open встигає спливти і запустити обробник на document.
Обробка вкладеної події повністю завершується до того, як управління повертається в зовнішній код (onclick).

Це справедливо не тільки для dispatchEvent, але і для інших ситуацій. JS в обробнику події може викликати інші методи, які приведуть до інших подій - вони також обробляються синхронно.

Якщо це не підходить, то можна або помістити dispatchEvent( або інший код, ініціюючий подію) в кінець обробника onclick, або якщо це не зручно, можна завернути генерацію події в setTimeout  з 0 затримкою.

<button id="menu">Menu</button>

  <script>
    menu.onclick = function(){
      alert(1);

    setTimeout(() => menu.dispatchEvent(new CustomEvent('menu-open', {
      bubbles: true,
    })));
      alert(2);
    }

    document.addEventListener('menu-open', ()=> alert('Вкладена подія'));
  </script>

  Порядок вивода: 1 -> 2 -> Вкладена подія -> 
  Тепер dispatchEvent  запускається асинхронно після виконання поточного кода, включаючи mouse.onclick, тому обробники повністю незалежні
*/