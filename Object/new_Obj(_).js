/* 
Теми:
- new Obj
- Ф-ція конструктор
- new.target 
- Особливості поведінки return*/
//Конструктор, оператор "new"
/* Дозволяє створювати багато схожих об'єктів */


//Ф-ція конструктор
/* Звичайна собі ф-ція, але має декілько узгоджень:
-Ім'я має починатись з великої літери
-Повинна виконуватись тільки за допомогою оператора "new" */

function User (name) {
  //this = {}; неявно
  //Додаються властивості до this
  this.name = name;
  this.isAdmin = false;
  //return this; неявно
} 
let user = new User ('Pypa');

console.log(user); //Pypa
console.log(user.isAdmin); //false
/* Коли ф-ція викликається як new User(...) відбувається ось що:
-Створюється новий порожній об'єкт і присвоюється this
-Виконується тіло ф-ції. Зазвичай воно модифікує this, додаючи нові властивості
-Повертається значення this */

/* Таким чином повертається той же р-тат, що і:
let user = {
  name: 'Pypa',
  isAdmin: false
}; 
Але тепер якщо буде необхідно створити інщих користувачів, достатньо буде викликати new User("Popa"), new User("Pipa")
Це основна мета конструктора - реалізовувати код для багаторазового створення однотипних об'єктів*/

/* Якщо в коді присутній складний об'єкт, то його можна завернути в ф-цію-конструктор, яка буде негайно викликана */
//Створюємо ф-цію і негайно викликаємо її за допомогою new
let users = new function () {
  this.name = 'Popa';
  this.isAdmin = false;
  /* Інший код для створення користувача */
};
/* Такий конструктор не може бути викликаний знову, так як він нігде не зберігається, просто створюється і відразу викликається. Такий трюк направлений на інкапсуляцію кода, який створює окремий об'єкт, без можливості повторного виклику в майбутньому  */

______
//Перевірка на виклик в режимі конструктора: new.target
//Використовується рідко
/* Використовуючи властивість ew.target всередині ф-ції, можна перевірити викликана ф-ція за допомогою new  чи без нього.
В випадку звичайного виклику new.target буде undefined , якщо викликана за допомогою new - new.target буде рівний самій ф-ції */

function Users () {
  console.log(new.target);
}
Users(); //undefined
new Users(); //ƒ Users () {console.log(new.target);}

//Можна зробити так щоб виклики з new  і без нього робили одне і теж 
function User1 (name) {
  if (!new.target) { //в випадку виклику без оператора new
    return new User1 (name); // додає new самостійно
  }
  this.name = name;
}
let pypa = User1('Pypa');
console.log(pypa.name); //Pypa
/* Такий підхід робить синтаксис більш гнучким, щоб можна було викликати ф-цію з new і без нього і щоб вона всеодно могла працювати */

______
//Повернення значення із конструктора, return
/* Конструктор не має оператора return, його задача записати все необхідне в this і це автоматично стає р-татом.
Але якщо return всетаки є, то використовується просте правило:
 - При виклику return з об'єктом, замість this повернеться об'єкт
 - При виклику return з примітивним значенням, воно ігнорується, тобто повернеться this   */

 //Тут return заміщяє this, повертаючи об'єкт
function BigUser () {
  this.name = 'Pypa';
  return {name: 'Godzilla'}; // <--- Поверне цей об'єкт
}
console.log(new BigUser().name); //Godzilla

//Приклад з порожнім return (або міг би бути примітив після return) 
function SmallUser () {
  this.name = 'Pypa';
  return; //<--- Поверне this
}
console.log(new SmallUser().name); //Pypa
/* Зазвичай в конструкторів відсутній return, це просто приклад його поведінки */

______
//Створення методів в конструкторі
/* Ф-ції конструктори створюють для об'єктів велику гнучкість і можуть мати параметри які визначають як створювати об'єкт і що в нього записувати */

function User2 (name) {
  this.name = name;
  this.sayHi = function () {
    console.log('Мене звати ' +this.name);
  };
}
let ann = new User2('Ann');
ann.sayHi(); //Мене звати Ann
/*
ann = {
   name: "Ann",
   sayHi: function() { ... }
}
*/