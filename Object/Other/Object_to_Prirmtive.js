/* 
Методи:
- Object.assign  /  SPREAD
 -Symbol.toPrimitive */


//Примітиви і об'єкти
//Примітив
let firstName = 'Pypa';
let firstName2 = firstName;
firstName = "New";
console.log(firstName); //New
console.log(firstName2); //Pypa
/* Примітивні типи зберігаються на Call Stack
Як це працює:
1.На Call Stack виділяється область пам'яті '0001' де зберігається змінна firstName і її значення 'Pypa'
2. Коли ми вказуємо, що firstName2 = firstName ми фактично вказуємо на одну і туж область пам'яті де зберігається змінна '0001'
3. Коли ми присфоюємо firstName "New" в нас створюється щє одна область пам'яті '0002' з новим значенням "New" 
Але так як ми не змінити firstName2 вона продовжує посилатись на 0001
А firstName посилається тепер на '0002'*/

//Об'єкт
const user1 = {
  name: 'Pypa',
};
const user3 = user1;
user3.name = 'Popa';
console.log(user1); //{name: 'Popa'}
console.log(user3); //{name: 'Popa'}
console.log(user1 === user3); // true
/* Reference type(об'єкти)зберігаються на heap(купі). Вони також мають область пам'яті в Call Stack, але вона зберігає лише силку на Heap тому що об'єкти можуть бути дуже великими. А Call Stack має обмеження, а те що в середині Heap, фактично не обмежена(тільки пам'яттю самого носія)
Як це працює:
1. Коли ми пишемо const user1 = {name: 'Pypa'}; створиться запис на Call Stack і виділиться під неї область пам'яті '0003'
2. В '0003' буде силка на об'єкт який знаходиться в heap
3. Ми присвоюємо user2 = user1
4. user2 посилається на туж область пам'яті '0003'
Тут починаються відмінності від примітивів
5. Змінюємо user2.name = 'Popa'. Тепер в heap де раніше лажела {name: 'Pypa'}, з'являється тепер {name: 'Popa'}
Ми не створюємо новий об'єкт як в примітивах, томущо для великих об'єктів це було б дуже ресурсо-затратно. Так оптимізується робота движка JS 
6. Тепер в області пам'яті Call Stack '0003' лежить user1 і user2 які мають одне посилання на об'єкт в heap(це одначає що вони рівні), але в ньому просто зміниться значення з {name: 'Pypa'} на {name: 'Popa'}

Тому що user1 константа, ми на Call Stack не можемо переприсвоїти йому якесь значення. Але в heap ми змінюємо об'єкт як нам потрібно*/

__________

const user = { //user змінна яка посилається на об'єкт
  name: 'Pipa',
  id: 1,
};
user.name = 'Pypa';
console.log(user); //{name: 'Pypa', id: 1}
/* const user це змінна яка посилається на область пам'яті з якої є силка на Heap в якій і лежить об'єкт
Константу не можна переписати!! 
Якщо потрібно змінити об'єкт повністю, потрібно використовувати let 
Тоді з'явиться нова область в Heap де створиться новий об'єкт.
і змінна буде посилаться на новий об'єкт, а старий буде лежати в купі поки його не очистять*/

 const newUser = user; //нова змінна яка посилається на тойже об'єкт
 user.name = 'NewUser'; // змінюємо в об'єкті одну властивість
 console.log(newUser); //{name: 'NewUser', id: 1}
 console.log(user); //{name: 'NewUser', id: 1}
 console.log(user === newUser); //true,змінні посилаються на один об'єкт в купі, тому вони рівні

 //Використовуючи Object.assign змінна newUsers буде мати не силку на об'єкт user, а на зовсім інший об'єкт. Але даний метод використовується рідко
 const user3 = { //user змінна яка посилається на об'єкт
  name: 'Popa',
  id: 1,
};
user3.name = 'Pipa';
const newUser2 = Object.assign({},user3);  
user3.name = 'Pepa';
 console.log(newUser3); //{name: 'Pipa', id: 1}
 console.log(user3); //{name: 'Pepa', id: 1}
 console.log(user3 === newUser3); //false, тепер це два різних об'єкта

 //SPREAD так само як і Object.assign копіює об'єкт, але робить це коротше і гарніше
 const user3 = {
  name: 'Jotaro',
  id: 1,
  roles: ['Admin']
 }
 console.log(user3); //{name: 'Jotaro', id: 1, roles: Array(1)}
 const newUser3 = {
  ...user3
 };  
user3.name = 'Dio';
newUser3.roles.push('User');
 console.log(newUser3); //{name: 'Jotaro', id: 1, roles: Array(2)}
 console.log(user3); //{name: 'Dio', id: 1, roles: Array(2)}
 console.log(user3 === newUser3); //false, тепер це два різних об'єкта
/*  Отримуємо теж саме, SPREAD бере властивості із першого об'єкта і копіює в новий. Таке копіювання можна чаасто зустріти. 
Але є одна особливість: 
Наш користувач user3 має властивість roles: ['Admin']. Скопіювавши об'єкт в іншу змінну newUser3 ми переписуємо цю ролю  newUser2.roles.push('User'); і отримаємо дивну штуку: user3 і newUser3 будуть мати властивість roles:['Admin', 'User']
Два різних об'єкта поводять себе так наче це силка на одну область пам'яті і це буде дійсно так.
Так як roles у властивості має масив який такожв яляється об'єктом. Тому roles буде посилаться на область пам'яті яка посилається на ['Admin']Тобто десь в окремій області памяті лежить масив. 
І коли ми робимо SPREAD копіювання, ми скопіювали roles, але силка на масив залишиласт таж сама. Тому він змінюється в обох змінних, так як вони мають силки на одну і туж область пам'яті де лежить масив
З такою проблемою можн впоратись за допомогою Deep clone (глибоку копіювання). Але воно використовується не часто , тому що це ресурсозатратно*/

__________
/* Якщо провести операцію віднімання або додовання між двома об'єктами, вони автоматично перетворяться в примітиви, потім виконається сама операція над примітивами і на виході ми отримаємо примітивне значення.
Це важливе обмеження !
Р-татом математичної операції не може бути інший об'єкт
Існує три варіанта перетворення типів, вони називаються хінтами :
1. STRING - перетворення об'єкта до рядка
2. NUMBER - перетворення об'єкта до числа
- Явне перетворення:
let num = Number(obj);
- Математичне:
let n = +obj;
- Порівняння:
let greater = user1 < user2;
3. DEFAULT - відбувається рідко, коли оператор невпенений який тип очікувати.
Неприклад якщо бінарний + отримує об'єкти в якості аргумента, він викорстовує хінт default
- бінарний плюс:
let total = obj1 + obj2;
- obj == number:
if (user == 1) {};

Оператори порівняння використовуюєть хінт number
*/
___
//Symbol.toPrimitive
/* Вбудований метод, який варто використовувати для обозначення метода перетворення . Єдиний метод який обробляє всі випадки перетворення*/
obj[Symbol.toPrimitive] = function(hint) {
  //код перетворення об'єкта в примітив, який поверне примітивне значення
};

//Приклад:
let userPrimitive = {
  name: 'Pypa',
  money: 10000,

  [Symbol.toPrimitive](hint) {
    console.log(`hint: ${hint}`);
    return hint == 'string' ? `{name: "${this.name}"}` : this.money;
  }
}; 
console.log(userPrimitive); //{name: 'Pypa', money: 10000, Symbol(Symbol.toPrimitive): ƒ}
console.log(+userPrimitive); //hint: number ->10000
console.log(userPrimitive + 500); //hint: default -> 10500
___
//toString / valueOf