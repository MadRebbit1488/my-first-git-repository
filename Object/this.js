/*
Використовується для доступу до інфо в середині об'єкта. Не фоусований
Значення this- це об'єкт перед крапкою, який викор для виклику метода.
*/
//Приклад:
let user = {
  name: 'John',
  age:30,

  sayHi () {
    //this - це поточний об'єкт
    console.log(this.name);
    console.log(this.age);
  } 
};
user.sayHi(); // John, 30
/* 
Під час виконання коду user.sayHi() значенням this буде являтись user (силка на об'єкт user ) .

Можна отримати доступ до об'єкта без ключового слова this, звернувшись до нього через зовнішню змінну(в якій зберігається силка на об'єкт)
*/
let user2 = {
  name: 'John',
  age:30,

  sayHi () {
    console.log(user2.name, user2.age);
  }
};
user2.sayHi(); // John 30
/* 
Але даний метод не надійний.Якщо потрібно буде скопіювати силку на об'єкт user в інщу змінну admin = user і перезаписати змінну user чимось іншим, тоді буде доступ до неправильного об'єкта при виклику метода із admin
*/

//this можна використовувати в ф-ціях, навіть якщо це не метод об'єкта, але this не має значення поки ф-ція не буде викликана
//Приклад: одна і таж ф-ція назначена двум об'єктам і має різне значення this при виклиці

let user3 = {name: "John"};
let admin = { name: "Admin" };

function sayHi () {
  console.log(this.name);
}
//викор одну і туж ф-цію в двох об'єктах
user3.f = sayHi;
admin.f = sayHi;
//this всередині ф-ції- це об'єкт перед крапкою
user3.f(); // John
admin.f(); //  Admin
admin['f'](); // Admin (немає різниці між крапкою і дужками для доступу до об'єкта)
// Якщо ф-цію викликати синтаксисом метода obj.method(), то підчас виклику "f", this – це obj

/* 
Стрілкові ф-ції не мають свого this . Якщо ми посилаємось на this всередині такої ф-ції, то воно береться із зовнішньої нормальної ф-ції
*/

let user4 = {
  firstName: 'Ilya',
  sayHi () {
    let arrow = () => console.log(this.firstName);
    arrow(); //Наскільки я розумію, це виклик ф-ції
  }  
}
user4.sayHi(); // Ilya
