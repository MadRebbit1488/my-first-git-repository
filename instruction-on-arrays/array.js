// DRY(Don't repeat yourself - не повторюйся)
/* Масив - це впорядкована структурована колекція даних, підвид об'єктів відкладених в пам'яті програми. Вони не представляють собою окремий тип даних , масив це - об'єкт.
[] - використовуються, щоб отримати доступ до властивості arr[] - по суті це звичайний синтаксис доступу до ключа, як obj[key], де в ролі obj => arr, а ключ => числовий індекс */

//У нас є раль користувача в компанії
const role1 = 'admin';
const role2 = 'user';
const role3 = 'superuser';

//Є масив рядків і тепер ми можемо працювати з ролями як з однією змінною яка містить набір однотипних значеннь 
const roles = ['admin', 'user', 'superuser'];
console.log(roles);
console.log(roles[0]); // [] по індексу показує елементи масиву
console.log(roles.length); // метод length показує довжину масиву
console.log(roles[roles.length -1]); //щоб отримати останній елемент масиву потрібно від довжини відняти 1, тому що індекс починається з 0

console.log(roles.at(0)); //Більш новіший спосіб отримання довжини масиву
//Перевага at в компактності 
console.log(roles.at(-1)); // Ось так можна визначити останній елемент масиву

//Масив зберігає різні типи даних
let arr = ['Яблуко', {name:'Ann'}, true, function(){console.log('Hi');}];
console.log(arr); // Array(4) [ "Яблуко", {…}, true, arr() ]
console.log(arr[3]()); //Викликає тіло ф-ції
console.log(arr[1].name); //Викликає ключ/властивість об'єкта


// В масивах можна використовувати тільки розрахункові вирази
// Вік користувача
const usersAge = [2040 - 2022, 20 - '6'];
console.log(usersAge);

// Не можна використовувати ствердження типу if...else, але можна використовувати тернарний оператор для розрахунків
const usersAge = [2040 - 2022, 10 > 0 ? 5 : 0];
console.log(usersAge);

// АЛЬТЕРНАТИВНИЙ СПОСІБ СТВОРЕННЯ МАСИВУ
const userNames = new Array('1', '3', '2');
console.log(userNames);

function square (el){
  return el * el;
}
// console.log(square(5)); //25
console.log(square([1, 2, 3])); // NaN, тому що проводиться операція з масивом, а не з конкретним елементом

function square (el){
  return el + el;
}
console.log(square([1, 2, 3])); //  1,2,31,2,3 (відбудеться конкатенація значень)
//Щоб працювати з кожним елементом по окремості потрібні методи перебору або щоб працювати із цілим масивом знадобляться вбудовані методи



______________________________________________________
//УПРАВЛІННЯ ЕЛЕМЕНТАМИ МАСИВУ
//Є масив користувачів
const users = ['1', '2', '3'];
console.log(users);
//Ротрібно 1 елемент замінити на інший
users[2] = '4';
console.log(users);
// users = ['1', '2', '4']; //Масив константа, йому не можна присвоїти нове значення перезаписавши всю змінну ,але можна модифікувати внутрішні елементи об'єктів
//Можна додавати елементи в масив
users[3] = '5';
console.log(users);


//У масивів є методи які дають змогу додавати і видаляти елементи

//
//Додавання в кінець push
/* Даний метод, це такаж ф-ція як console.log, тільки над масивом . Вихідний масив мутується, присвоєння нового значення не відбувається. push полегщує додавання елементів в кінець масиву, без визначення індексу останнього елемента */
users.push('5');
console.log(users);
/* push повертає довжину зміненого масиву
Його можна  покласти в  константу, щоб  одразу отримати нову довжину  */
const arrLength = users.push('5'); 
console.log(users);
console.log(arrLength);

//
//Додавання на початок unshift
//Зміщує всі елементи, те що спочатку було під індексом 0 тепер під індексом 1 і т.д
users.unshift('6');
console.log(users);

//
//Видалення в кінці pop
//Повертоє результат видаленого елементу
const el =users.pop();
console.log(el);
console.log(users);

//
//Видалення на початку shift
const el2 = users.shift();
console.log(el2);
console.log(users); 

// Методи push і shift можуть додавати одночасно к-ка елементів
const num = ['3'];
num.push('4', '5'); //Array(3) [ "3", "4", "5" ]
num.unshift('0', '1', '2'); //Array(4) [ "0", "1", "2", "3" ]
console.log(num); // Array(6) [ "0", "1", "2", "3", "4", "5" ]




________________________________________________________________________
// ПОШУК ЕЛЕМЕНТІВ

//
//indexOf
//використовується щоб отримати конкретний індекс

//Є користувач у якого багато ролей
const roles = ['user', 'admin', 'manager'];
//І нам потрібно пропустити користувача якщо в нього є  роль, наприклад адмін
const elIndex = roles.indexOf('admin');
console.log(elIndex);  //1 , повертає індекс на якому знаходиться елемент
//indexOf перебирає масив, знаходить перше входження і повертає його індекс. 
//Якщо індекс не знайшовся indexOf завжди буде негативним -1
const elIndex2 = roles.indexOf('superuser');
console.log(elIndex2); // -1
//Можна записати перевірку, але такий синтаксис використовується дуже рідкл
if(roles.indexOf('admin') >= 0){
  console.log('Доступ надано');
}
//Це працює, тому що ми отримуємо індекс і якщо він існує то може бути 0, 1, 2 і т.д тобто будь-яке число від 0 і більше. Якщо його немає, то буде -1
if(roles.indexOf('superuser') >= 0){
  console.log('Доступ надано'); // -1
}

//
//includes
//Повертає true або false
//Простіший метод перевірки
console.log(roles.includes('admin')); // true
console.log(roles.includes('superuser')); //false
//Такий синтаксис використовується частіше, по причині простого, інтуїтивного запису. Використовується для перевірки значення елемента
if(roles.includes('admin')){
   console.log('Доступ надано');
} 
 


_________________________________________________________________________
// ПЕРЕТВОРЕННЯ РЯДКІВ І МАСИВІВ ОДИН В ОДНОГО

//РЯДОК => МАСИВ
//split(розбити) - метод рядка, який дозволяє перетворювати(розділяти) вихідний рядок до масива не модифікуючи його. В якості аргумента він приймає симвал по якому потрібно розбити вихідний рядок на масив(/)
//Нам приходить рядок з url(для нього існують окремі методи
const url = 'auth/user/login';
//Ми хочемо отримати кожний сегмент. 
const res = url.split('/');
//Ми вказали, що нам потрібно розбити по / і вийшло три елемента
console.log(res); //Array(3) [ "auth", "user", "login" ]

/* Якщо помтавити на початку / буде чьотири елемента
 const url = '/auth/user/login';
const res = url.split('/');
console.log(res); //Array(4) [ "", "auth", "user", "login" ] */

//МАСИВ => РЯДОК
//join - поєднує елементи масива в рядок
const roles = ['user', 'admin', 'manager', 'superuser'];
console.log(roles.join('-')); // user-admin-manager-superuser */


