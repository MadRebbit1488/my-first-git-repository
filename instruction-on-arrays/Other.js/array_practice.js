//Задача №1
/* Дано список задач
const tasks = ['Задача 1'];
Зробити ф-ції:
-Додавання задачі в кінець
-Видалення задачі по назві
-Перенесення задачі на початок списка по назві
Завжди змінюємо вихідний масив */

const tasks = ['Задача 1'];
//Ф-ція додавання задачі приймає в якості аргумента нову задачу tasks
function add (task) {
   tasks.push(task);
}
//Ф-ція модифікує вихідний масив

function remove(task){
  //Знаходимо індекс елемента який будемо видаляти
    const index = tasks.indexOf(task);
    if(index === -1){
      return; // Завдяки return ф-ція не модифікується якщо потрібний елемент масиву не знайдено
    }
  //Видаляємо за допомогою метода splice який модифікує вихідний масив  
    return tasks.splice(index, 1); // 1 вказує на те, що видаляється один елемент . return повертає tasks якщо він знайдений , в іншому випадку undefined
}

//Щоб приорітизувати задачу потрібно прибрати її із сторого місця і додати в початок
function prioritize (task) {
    const result = remove(task); //Видаляємо task
    if(!result){
      return;
    }
    tasks.unshift(result[0]); //Додаємо задачу на початку
  /*   const index = tasks.indexOf(task); //Отримуємо індекс задачі
    if(index === -1){
      return;
    }
    const oldTask = tasks[index];   //Зберігаємо стару задачю з індексом в змінну
    tasks.splice(index, 1); //Видаляємо елемент */
}

add ('Задача 2');
add ('Задача 3');
console.log(tasks); //Array(3) [ "Задача 1", "Задача 2", "Задача 3" ]
remove ('Задача 2');
console.log(tasks); //Array [ "Задача 1", "Задача 3" ]
prioritize('Задача 3');
console.log(tasks); //Array [ "Задача 3", "Задача 1" ]
 
//Такий метод написання ф-ція порушує принцип DRY



_________________________________________________________________________
//Задача №2
/* Написати ф-цію congratsIfMoreThan100() яка аргументом приймає масив даних(користувачів) і виводить на екран за допомогою ф-ції alert() привітання, якщо користувачів більше 100. */

const usersArr = [
  {name: 'user1', age: 20},
  {name: 'user2', age: 30},
  {name: 'user3', age: 20}
];

function congratsIfMoreThan100(arr) {
  if(arr.length > 2){
    alert('H!');
    alert(arr.length);
  }else {
    alert('g');
  }
}

congratsIfMoreThan100(usersArr);
//Ф-ція має один аргумент, мосив . І перевіряє чи масив який їй прийде немає більше елементів

_________________________________________________________________________
//Задача №3
//Яка довжина масиву 
let arr1 = ['Ваня', 'Іван', 'Оля'];

let newArr1 = arr1;
newArr1.push('Petia');
console.log(arr1.length); //4
_________________________________________________________________________
//Задача №4
/*-Створіть масив users з елементами 'Ваня' і 'Іван'. 
-Додайте елемент 'Оля' в кінці. 
-Замініть значення 'Іван'на 'Петя'.
-Код для пошуку має працювати з масивами будь якої довжини .
-Видаліть перший елемент масиву і покажіть його .
-Вставет "Маша" і "Паша" на поічаток масиву
 */

let arr = ['Ваня', 'Іван'];
arr.push('Оля'); 
arr[1] = 'Петя';
let del = arr.shift();
console.log(del); //Ваня
arr.unshift('Маша', 'Паша');
console.log(arr); //  ["Маша", "Паша", "Петя", "Оля"]

_________________________________________________________________________
//Задача №5
//Видалити елемент 'Іван' і повернути його в змінну
let arr12 = ['Ваня', 'Іван', 'Оля'];
let newVariable = arr12.splice(1, 1);
console.log(newVariable); //Array [ "Іван" ]
_________________________________________________________________________
//Задача №6
//Зробити із рядка масив
let str = 'Ваня, Іван, Оля';

let newArr = str.split(',');
console.log(newArr); //Array(3) [ "Ваня", " Іван", " Оля" ]

_________________________________________________________________________
//Задача №7
//Чьому рівний previousValue на початку роботи метода?
let arr = [9, 2, 8];
let reduceValue = arr.reduce(function(previousValue, item, index, array){
  console.log(previousValue); //9
});
_________________________________________________________________________
//Задача №8
//Чи скопіюється масив?
let fruits = ['Яблуко', 'Груша', 'Апельсин',];
let shoppingCart = fruits;
shoppingCart.push('Банан');
console.log(shoppingCart); //Array(4) [ "Яблуко", "Груша", "Апельсин", "Банан" ]
console.log(fruits); //Array(4) [ "Яблуко", "Груша", "Апельсин", "Банан" ]
//Так

_________________________________________________________________________
//Задача №9
/* 1. Створити мвасив styles з елементами 'Джаз' і 'Блюз'
2.Додати 'Рок-н-рол' в кінець
3. Замінити значення в середині на 'Класика'.
4.Видалити перший елемент масиву і показати його
5.Вставити 'Рок' і 'Метал' на початок масиву
*/


const styles = ['Джаз', 'Блюз'];
styles.push('Рок-н-рол'); //Array(3) [ "Джаз", "Блюз", "Рок-н-рол" ]
styles.splice(1, 1, 'Класика'); // Array(3) [ "Джаз", "Класика", "Рок-н-рол" ]
let delPop = styles.shift();
console.log(delPop); //  Джаз  ; Array [ "Класика", "Рок-н-рол" ]
styles.unshift('Рок', 'Метал'); //Array(4) [ "Рок", "Метал", "Класика", "Рок-н-рол" ]
console.log(styles);

_________________________________________________________________________
//Задача №10
//Виклик в контексті масиву
let array = ['a', 'b'];

array.push(function(){
  console.log(this);
});

array[2](); //a,b,function(){...}
/* Виклик array[2]() метод об'єкта, в ролі obj - array, в ролі method - 2.
Є виклик ф-ції array[2] як метод об'єкта. Відповідно він отримує в якості this об'єкт array і виводить масив */

_________________________________________________________________________
//Задача №11

//Сума виведених чисел
/* Напишіть ф-цію sumInput(), яка:
-Просить користувача ввести значення, використовуючи prompt і зберігає їх в масиві
-Закінчує запитувати значення, коли користувач введе не числове значення, порожній рядок або натисне "Відміна".
-Підраховує і повертає суму елементів масиву
P.S. 0 - вважається числом */

function sumInput () {
  let numbers = [];
  while (true) {
    let value = prompt('Введіть число', '');

    //Припиняємо введення
    if (value === "" || value === null || !isFinite(value)) break;

    numbers.push(+value);
  }

  let sum = 0;
  for(let number of numbers ) {
    sum += number;
  }
  return sum;
}

console.log(sumInput());

_________________________________________________________________________
//Задача №12
//Підмасив найбільшої суми
/* На вході масив чисел: arr = [1, -2, 3, 4, -9, 6];
Задача: знайти безперервний півдмасив в arr, сума елементів в якому максимальна.
Ф-ція getMaxubum(arr) повинна повертати цю суму. 
Наприклад:
getMaxSubSum([-1, 2, 3, -9]) == 5 (сума виведених елементів)
getMaxSubSum([2, -1, 2, 3, -9]) == 6
getMaxSubSum([-1, 2, 3, -9, 11]) == 11
getMaxSubSum([-2, -1, 1, 2]) == 3
getMaxSubSum([100, -9, 2, -3, 5]) == 100
getMaxSubSum([1, 2, 3]) == 6 (беремо все)

Якщо всі елементи негативні - нічього не беремо(підмасив порожній) і сума рівна "0":  getMaxSubSum([-1, -2, -3]) = 0 */


//Рішення від GPT-4
/* Щоб знайти безперервний підмасив з максимальною сумою елементів, ми можемо використовувати алгоритм "максимуму за допомогою додавання". Алгоритм полягає в тому, щоб пройтися по масиву і додавати кожен елемент до поточної суми. Якщо поточна сума стає від'ємною, ми починаємо заново з наступного елемента. Кожного разу, коли ми додаємо новий елемент, ми перевіряємо, чи є поточна сума більшою за максимальну знайдену суму до цього моменту. Якщо так, ми оновлюємо максимальну суму та зберігаємо індекси початку та кінця поточного підмасиву з максимальною сумою. */

/* Ідемо по масиву і накопичкємо часткову суму елементів в змінній. Якщо вона в якийсь момент стає негативною - присвоюємо їй "0" */

function getMaxSubSum(arr) {
  let maxSum = 0;
  let partialSum = 0;

  for (let item of arr) {
    partialSum += item;
    maxSum = Math.max(maxSum, partialSum);
    if (partialSum < 0) partialSum = 0;
  }
  return maxSum;
}

console.log( getMaxSubSum([-1, 2, 3, -9]) ); // 5
console.log( getMaxSubSum([-1, 2, 3, -9, 11]) ); // 11
console.log( getMaxSubSum([-2, -1, 1, 2]) ); // 3
console.log( getMaxSubSum([100, -9, 2, -3, 5]) ); // 100
console.log( getMaxSubSum([1, 2, 3]) ); // 6
console.log( getMaxSubSum([-1, -2, -3]) ); // 0

_________________________________________________________________________
//Задача №13
//Перевести текст  border-left-width в borderLeftWidth
/* Напишіть ф-цію camelize(str), яка перетворює рядки. Дефіси видаляються, а всі слова після них з великої букви .
Викор split, щоб розбити рядок на масив символів , і методом join зібрати все назад */


function camelize (str) {
  return str .split('-') // розбиває border-left-width на масив ['border', 'left', 'width']
    .map(
      //Переводить у верхній регістр перші букви всіх елементів масиву за винятком перщого. Перетворює в ['border', 'Left', 'Width']
      (word, index) => index == 0 ? word : word[0].toUpperCase() + word.slice(1)
      ) .join(''); //Об'єднує ['border', 'Left', 'Width'] в 'borderLeftWidth'
}
console.log(camelize('border-left-width'));  //borderLeftWidth
//Ф-ція розбиває рядок на масив рядків, використовуючи "-" в якості розділювача. Потім вона проходить по всім елементам масива, перетворюючи кожне слово: першу букву кожного слова, починаючи з другого, робить заголовною, а дефвси видаляє.Потім ф-ція об'єднує всі слова разом і повертає рядок
_________________________________________________________________________
//Задача №14
//Фільтрація по діапазону
/* Напишуті ф-цію filterRange(arr, a, b), яка приймає масив arr, шукає елементи із значенням більше або рівно "а" і менше або рівно "b" і повертає р-тат в вигляді масиву. Ф-ція повинна повертати новий масив не модифікуючи вихідний. */

function filterRange(arr, a, b) {
    return arrFiltered.filter(item => (a <= item && item <= b));
}

let arrFiltered = [5, 3, 8, 1];

let filtered = filterRange (arrFiltered, 1, 4 );
console.log(filtered); //Array [ 3, 1 ]
console.log(arrFiltered); //Array(4) [ 5, 3, 8, 1 ]

_________________________________________________________________________
//Задача №15
//Фільтрація по діапазону не місці
/* Напишіть ф-цію filterRangeInPlace(arr, a, b), яка приймає масив arr і видаляє із нього всі значення окрім тих, які знаходяться між a і b. Тобто, перевіка має вигляд a ≤ arr[i] ≤ b.
Ф-ція має змінювати масив який приймає і нічього не повертати. */

function filterRangeInPlace (arr, a, b) {
  for (let i = 0; i < arr.length; i++) {
    let val = arr[i];

    //Видаляє за межами інтервалу
    if (val < a || val > b){
      arr.splice(i, 1);
      i --;
    }
  }
} 

let arr = [5, 3, 8, 1];
filterRangeInPlace (arr, 1, 4); //Видаляє числа поза діапазоном 1..4
console.log(arr); //Array [ 3, 1 ]

/* 
Код містить ф-цію filterRangeInPlace яка приймає масив "arr" та два числа "a" та "b". Ф-ція фільтрує масив, видаляючи всі елементи, що не лежать в діапазоні від "a" до "b" і змінює масив без повернення нового масиву.
Конструкція for перебирає всі елементи масиву. Змінна "і" використовується як лічильник ітерації, починаючи з нуля. Умова циклу "i < arr.length" гарантує виконання циклу доки лічильник "і" менший за довжину масиву.
Оголошенна змінна "val" отримує значення елементу масиву з індексом "і".
Код в тілі циклу виконується для кожного елементу масиву окремо, починаючи з елемента з індексом 0.
Розгалуження if перевіряє чи належить елемент масиву "val" діапазону від "a" до "b" . Якщо не належить, він видаляється з масиву методом splice(i, 1), де "і" - індекс поточного елемента, а "1" - к-ть елементів які потрібно видалити починаючи з цього індексу. Щоб уникнути пропуску перевірки елементів, які знаходяться після видаленого елемента, змінна "і" зменщується на 1 (і--). Це необхідно, тому що після видал поточного елемента наступним елементом масиву стає елемент з індексом "і". А в наступній ітерації цикл лічильнику "і" збільшується на 1.Якщо не зменшити "і" на одиницю після видалення, то наступний елемент не буде перевіреним
*/
_________________________________________________________________________
//Задача №16
//Сортування в порядку спадання

let arr = [5, 2, 1, -10, 8];
arr.sort((a, b) => b - a);
console.log(arr); //Array(5) [ 8, 5, 2, 1, -10 ]

_________________________________________________________________________
//Задача №17
//Скопіювати і відсортувати масив
/* Потрібно відсорторувати копію, але вихідний масив залищити незмінним.Створити ф-цію copySorted(arr), яка буде повертати копію. */

let arrCopy = ['HTML', 'JS', 'CSS'];
function copySorted (arrCopy) {
  return arrCopy.slice().sort(); //Копіює масив і відсортовує
}
let sorted = copySorted  (arrCopy);

console.log(sorted); //Array(3) [ "CSS", "HTML", "JS" ]
console.log(arrCopy);// Array(3) [ "HTML", "JS", "CSS" ]

_________________________________________________________________________
//Задача №18
//Створити розширений калькулятор
/* Створити ф-цію конструктор Calculator, яка створить розширені об'єкти калькулятора.
Створення складається із 2 частин:
1. Реалізації методу calculate(str), який приймає рядок типу "1+2" в форматі "Число оператор Число" (розділені пробілами) і повертає р-тат.Метод має розуміти "+" і "-".

2. Потім додати addMethod(name, func), який додає калькулятор в нові операції. Він приймає оператор name і ф-цію з двома аргументами func(a,b), яка опимує його.Calculator */


function Calculator () {
  this.methods = {
    '-': (a, b) => a - b,
    '+': (a, b) => a + b
  };
  this.calculate = function(str) {
    let split = str.split(' '),
      a = +split[0],
      op = split[1],
      b = +split[2]

      if(!this.methods[op] || isNaN(a) || isNaN(b)) {
        return NaN;
      }
      return this.methods[op](a, b);
  }
  this.addMethod = function (name, func) {
    this.methods[name] = func;
  };
}

console.log(Calculator.calculate('3+4'));

_________________________________________________________________________
//Задача №19
//Трансформувати в масив імен

let vasya = {name: 'Вася', age: 25};
let petya = {name: 'Петя', age: 30};
let masha = {name: 'Маша', age: 28};

let users = [vasya, petya, masha ];
let names = users.map(item => item.name);

console.log(names); //Array(3) [ "Вася", "Петя", "Маша" ]
_________________________________________________________________________
//Задача №20
//Трансформувати в об'єкти
/* Є масив об'єктів user, і у кожного об'єкта є name, surname і id.
Потрібно написати код який створить щє один масив об'єктів з параметрами id і fullName, де fullName - складається із name і surname. */

let vasya2 = {name: 'Вася', surname: 'Пупкин', id: 1};
let petya2 = {name: 'Петя', surname: 'Иванов', id: 2};
let masha2 = {name: 'Маша', surname: 'Петрова', id: 3};

let users2 = [vasya2, petya2, masha2];

let usersMapped = users2.map(user => ({ //В стрілковій ф-ції потрібно додатково використовувати (), так як JS {} <=такі дужки буде трактувати як початок ф-ції, а не об'єкта
  fullName: `${user.name} ${user.surname}`,
  id: user.id
})) ;

/*
usersMapped = [
  { fullName: "Вася Пупкин", id: 1 },
  { fullName: "Петя Иванов", id: 2 },
  { fullName: "Маша Петрова", id: 3 }
]
*/

console.log(usersMapped[1].id); //2
console.log(usersMapped[1].fullName); // Петя Иванов
_________________________________________________________________________
//Задача №21
//Відсорторувати користувачів по віку
/* Напишіть ф-цію sortByAge(users), яка прийймає масив об'єктів із властивістю age  і сортує їх по ній. */

let vasya1 = {name: 'Вася', age: 25};
let petya1 = {name: 'Петя', age: 30};
let masha1 = {name: 'Маша', age: 28};

let arr = [vasya1, petya1, masha1];

function sortByAge (arr) {
  arr.sort((a, b) => a.age > b.age ? 1 : -1);
}


sortByAge (arr);

console.log(arr[0].name); // Вася
console.log(arr[1].name); // Маша
console.log(arr[2].name); // Петя

/* 
Дана ф-ція яка приймає масив як вхідні дані та сортує його на основі "age" властивостей об'єктів у масиві. Метод "sort" викор з ф-цією зворотнього виклику, яка порівнює властивість "age"  двох об'єктів ("а" і "b") і повертає значення, яке визначає порядок, у якому вони мають бути відсортовані.
Ф-ція порівняння викор тернарний оператор ( a.age > b.age ? 1 : -1) для порівняння "age" властивостей обох об'єктів. Якщо "a.age" більше ніж "b.age", ф-ція повертає "1", вказуючи що "а" має бути після "b". В іншому випадку ф-ція поверне "-1", вказуючи, що "b" має бути після "а".
Ф-ція sortByAge нічього не повертає і не модифікує оригінальний масив.
*/
_________________________________________________________________________
//Задача №22
//Перемішати масив
/* Напишіть ф-цію shuffle(array), яка перемішує ( переупорядковує випадковим чином) елементи масиву.
Багаторазові прогони через shuffle можуть призвести до різної послідовності елементів. */


let arr = [1, 2, 3];

function shuffle (arr) {
  arr.sort(() => Math.random () - 0.5);
}

shuffle (arr);
console.log(arr); //Array(3) [ 2, 3, 1 ] / Array(3) [ 3, 2, 1 ] /Array(3) [ 2, 1, 3 ]

/* 
Math.random - 0.5 віддає випадкове число, яке може бути позитивним або негативним , відповідно ф-ція сортування змінює порядок елементів виподковим чином.
*/
_________________________________________________________________________
//Задача №23
//Отримати середній вік
// Напишіть ф-цію getAverageAge(users), яка приймає масив об'єктів із властивістю age  і повертає середній вік.

let vasya3 = { name: "Вася", age: 25 };
let petya3 = { name: "Петя", age: 30 };
let masha3 = { name: "Маша", age: 29 };

let arr = [ vasya3, petya3, masha3 ];
function getAverageAge (users) {
   return users.reduce((prev, user) => prev + user.age, 0) / users.length;
}

console.log(getAverageAge(arr)); //28

// prev => previous = Попередній
_________________________________________________________________________
//Задача №24
//Залишити унікальні елементи масиву
//arr - масив рядків. Напишіть ф-цію unique(arr), яка повертає масив, який містить тільки унікальні елементи arr.

function unique (arr) {
  let result = [];

  for (let str of arr) {
    if (!result.includes(str)) {
      result.push(str);
    }
  }
  return result;
}

let strings = ['крішна','крішна', 'харе','харе','харе','харе','крішна','крішна',':-0'];

console.log(unique(strings)); //Array(3) [ "крішна", "харе", ":-0" ]

/* 
Ф-ція unique приймає масив arr як вхідні дані та повертає новий масив лище з інукальними значеннями з arr. Ф-ція використовує цикл для повторення кожного елемента в arr і якщо елемента щє немає в result мисиві, він додається до result масиву за допомогою push методу .
Метод includes використовується для перевірки наявності елемента в result мсиві. Якщо елемент не знайдено в result масиві, це означає, що він унікальний і додається в  result масив за допомогою push методу.
Вираз  if (!result.includes(str)) використовується для перевірки str наявності елемента в result. Метод includes викликається для result масиву з str елементом як аргумент. Якщо str елемент знайдено в result масиві, includes поверне true, а оператор "!" заперечить його, в р-таті чього буде  false.
І навпаки, якщо str елемент не знайдено в result масиві, includes поверне false, а  оператор "!" заперечить його, в р-таті чього буде  true.
Таким чином !result.includes(str) поверне true якщо str елемент не знайдено в  result масиві і false в іншому випадку.

1. 'крішна' так як його немає в масиві result він буде false, але оператор "!" це заперечить і буде true
2. 'крішна' так як такий елемент вже є в масиві result, str буде true, але  "!" заперечить це і str стане false і.т.д
*/
_________________________________________________________________________
//Задача №25
//Створити об'єкт з ключами із масива
/* Є масив користувачів в вигляді{id:..., name:..., age:... }.
Створіть ф-цію groupById(arr), яка створить із нього об'єкт з id в якості ключа і елементами масиву в якості значень. */

function groupById (array) {
  return array.reduce((obj, value) =>{
    obj[value.id] = value;
    return obj;
  }, {})
}

let users1 = [
  {id: 'john', name: 'John Smith', age: 20},
  {id: 'ann', name: 'Ann Smith', age: 24},
  {id: 'pete', name: 'Pete Peterson', age: 31},
];


let usersById = groupById (users1);

console.log(usersById);/* Object {  
              ann: Object { id: "ann", name: "Ann Smith", age: 24 }
              john: Object { id: "john", name: "John Smith", age: 20 }
              pete: Object { id: "pete", name: "Pete Peterson", age: 31 }
} */
_________________________________________________________________________
//Задача №26
/* Даний довільний url - 
'https://purpleschool.ru/course/javascript'
Потрібно зробити ф-цію, яка виводить в консоль:
-Протокол(https)
-Доменне ім'я (purpleschool.ru)
-Шлях в середину сайта (/course/javascript)
*/


const url = 'https://purpleschool.ru/course/javascript';

function getUrlParts (url) {
  let [protocol,_, host, ...path] = url.split('/');
  if (protocol === 'https:' || protocol === 'http:') { //Перевірка на вірність протоколу
    if (!host.includes('.')){ //Перевірка на правильність домена
      return;
    }
    console.log(protocol, host, path);
    console.log(`Протокол: ${protocol.split(':')[0]}`);
    console.log(`Доменне ім'я: ${host}`);
    console.log(`Шлях в середину сайта: /${path.join('/')}`);
  }
}

getUrlParts(url);
_________________________________________________________________________
//Задача №27
/* 
Є мас змінення цін prices, де всередині 1-й елемент масиву являється ціною в момент Х, 2-й в момент У.
Потрібно перетворити дані в масив, де будуть відображатись тільки позитивні зміни цін: [100, 150] 
*/

const prices = [[100, 200], [120, 100], [200, 350]];

//Як вирішила я. Я просто вивела ціну з позитивною націнкою, а треба було вивести суми позитивних націнок. Упсь, незрозуміла умову
const pricesOperation = prices
.filter(index => {
  return index[1] > index[0]
})
.map(index => index[1] > index[0] ? index[1] : index[0]);

console.log(pricesOperation); //[200, 350]


//Яке рішення коректніше
//Використовуємо map для перетворення, а потім filter, щоб відфільтрувати негативні значення
//product - масив, тому що це масив в масиві
const result = prices
//Виконаємо операцію віднімання, щоб перетворити масив з масивом просто в масив
.map(product => product[1] - product[0])
//Далі це все потрібно відфільтрувати
.filter(price => price > 0);
console.log(result); //[100, 150]
_________________________________________________________________________
//Задача №28
//Знайти середнє значення послідовних чисел за допомогою reduce
const arr = [2, 4, 4, 10];

//Моє ріщення
const averageValue = arr.reduce((acc, ell) => {
return acc + ell
/ arr.length
}, 0);

console.log(averageValue); //5

 const avg = arr.reduce((acc, ell, i) => {
  if (i != arr.length -1) {
    return acc + ell; //Якщо це не останній елемент, то портрібно повернути наступним елементом суму acc + ell
  } else { //Якщо це не так, значить це останній елемент і потрібно повернути його в avg
    return (acc + ell) / arr.length;
  }
}, 0);
//Логіка прописана не просто на сумування елементів, а в залежності від того останній цей елемент чи ні, правильно передавати в acc наступний елемент, а в кінці передати не просто сумму, а сумум / на arr.length
console.log(avg); //5
_________________________________________________________________________
//Задача №29
