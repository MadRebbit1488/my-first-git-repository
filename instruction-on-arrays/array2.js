//Є масив користувачів
const usersArr = [
  {name: 'user1', age: 20},
  {name: 'user2', age: 30}
];

const newUsers = true;
//Додаємо нового користувача до масиву
if(newUsers){
  usersArr.push({name: 'user3', age: 33}); // В кінець
  //usersArr.unshift({name: 'user3', age: 33}); // На початок
  // usersArr.pop(); //Видаляє з кінця
  // usersArr.shift();// Видаляє на початку
  //Видаляє вказаний елемент з масиву і дає змогу додавати на його місце новий
  // usersArr.splice(-1);  //Видаляє останній елемент
  //Видаяляє з першого елемента по третій , але не враховуючи його
  // usersArr.splice(1, 2); //Залишає перший елемент
  // usersArr.splice(0, 1); //Видаляється перший елемент
  // usersArr.splice(0, 1, {name:'user0', age:15}); //Таким чином видаляється перший елемент об'єкта і заміняється новим
}

console.log(typeof usersArr); // Object { name: "user3", age: 33 }

// В методі splice(1, 2) перший індекс вказує на те який елемент в списку видаляти, другий - скільки
 

console.log(usersArr.length);
usersArr.push( {profession: 'QA'} );
console.log(String(usersArr));


_________________________________________________________________________
const arr= [1, 2, 3];
//Бінарний + об'єднує дані приводячи їх до рядка
alert("" + 1); //1
alert("1" + 1); //11
alert("1,2" + 1); //1,21
console.log(arr);
 
____________________________________________________________
/* Щоб отримати доступ до елементу об'єкта в масиві потрібно в () після імені масиву вказати індекс об'єкта в [], а потім через крапку ім'я ключа:
console.log(arrTwo[1].type); */
/* Щоб виконати тіло ф-цію потрібно в виклиці після позиції ф-ції [] поствити () */

_________________________________________________________________________//Багатомірний масив , тобто коли елементи масиву самі являються масивами
const matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];
console.log(matrix);
console.log(matrix[2][1]); //8
//[2]-елемент масиву, який являється також масивом ; [1] - ключ/позиція елементу
___________________________________________________________________________
//Масив поводить себе як об'єкт, тобто копіюється за посиланням
const arr01 = ['1', '2', '3'];
let newArr = arr01; // Присвоюємо масив змінній
console.log(newArr.length); //3
newArr.length = 2; // Вкорочуємо масив
console.log(arr01); //Array [ "1", "2" ]
//Сам масив по суті не змінився, просто тепер до нього є два ключа
___________________________________________________________________________
//Видалення
const arr02 = ['1', '2', '3'];
delete arr02[1];
console.log(arr02); //Array(3) [ "1", <1 empty slot>, "3" ]
console.log(arr02[1]); // undefined
console.log(arr02.length); // 3
//При використанні метода delete, к-сть елементів масиву не зменшується , замість видаленого елементу залищається порожній слот <1 empty slot>,\
_________________________________________________________________________
//dplice - дозволяє додавати, видиляти і замінювати елементи
//Синтаксис : arr.splice(index[, deleteCount, elem1, ...elemN])
//Видалляємо елемент
let arr1 = ['1', '2', '3'];
// Починаючи з першої позиції (2), видаляємо 1 елемент
arr1.splice(1, 1);
console.log(arr1); //Array [ "1", "3" ]

//Видаляємо елемент і повертаємо його в змінну
let arr2 = ['1', '2', '3'];
let remove = arr2.splice(1, 1);
console.log(remove); //Array [ "2" ]

//Замінюємо елементи
let arr3 = ['1', '2', '3'];
//Починаючи з нульової позиції (1), замінюємо один елемент
arr3.splice(0, 1, '1,5');
console.log(arr3); //Array(3) [ "1,5", "2", "3" ]

//Додаємо елемент
let arr4 = ['1', '2', '3'];
//Починаючи з першої позиції (перед 2), додаємо два елемента
// 1 - означає перед першою позицією
//0 - означає, що щось додається, без видалення об'єктів
arr4.splice(1, 0, '1,6', '1,7');
console.log(arr4); //Array(5) [ "1", "1,6", "1,7", "2", "3" ]

//Видаляємо елемент
let arr5 = ['1', '2', '3'];
//Починаючи з останньої позиції (3), видаляємо один елемнт
arr5.splice(-1, 1);
console.log(arr5); //Array [ "1", "2" ]
_________________________________________________________________________
//Метод slice
//Створює новий масив, в який копіює частину або весь масив
//Синтаксис: arr.slice([start], [end] не включаючи [end])

//Копіюємо частину масиву
let arr6 = ['1', '2', '3'];

//Починаючи з першої позиції ('2') до другої позиції ('3') але не включно
let arr7= arr6.slice(1, 2);
console.log(arr7); //Array [ "2" ]

//Починаючи з передостаньої позиції ('2') до останьої ('3') але не включно
let arr8 = arr6.slice(-2, -1);
console.log(arr8); //Array [ "2" ]

//Копіюємо весь масив
let arr9 = arr6.slice();
console.log(arr9); //Array(3) [ "1", "2", "3" ]
_________________________________________________________________________
//Метод concat
//Створює новий масив, в який копіює дані із інших масивів і додаткові значення (в кінець масиву)
//Синтаксис arr.concat(arg1, arg2...)
 let arr10 = ['1', '2', '3'];
 let arr11 = arr10.concat('4'); //Додає нове значення, думаю в такому форматі діє аналогічно методу push 
  console.log(arr11); //Array(4) [ "1", "2", "3", "4" ]
_________________________________________________________________________
//Пошук в масиві
//Методи indexOf/lastIndexOf/includes
//Аналоги строкових методів

/* 1.arr.indexOf(item, from) шукає item, починаючи з індекса from, і повертає індекс, на якому був знайдений шукаємий елемент, в іншому випадку -1 
2.arr.lastIndexOf(item, from) - те ж саме, але шукає справа на ліво.
3.arr.includes(item, from) - шукає item, починаючи з індекса from, і повертає true, якщо пошук успішний. 
 */

let arrRaid = ['Дора', 'дора', 'помідора'];

//indexOf
console.log(arrRaid.indexOf('Дора')); //0
console.log(arrRaid.indexOf('Дора', 2)); // -1

//includes
console.log(arrRaid.includes('Дора')); // true
console.log(arrRaid.includes('Дора', 2)); // false
___________________________________________________________________________
//Пошук в масиві
//find і findIndex
//Пошук в масиві об'єктів з певною умовою і повертають перший трапившийся елемент(find) , або його індекс(findIndex), який задовольнить умову

/* Синтаксис:
let result = arr.find(function(item, index, array) {
  якщо true - повертається поточний елемент і перебір припиняється
  якщо всі ітерації виявились хибними, повертається undefined
});
 */

let arrFind = [
  {name:'pypurka', age:14},
  {name:'pizhma', age:19},
  {name:'dinorik', age:'Не скажу'},
]
//Звертаємось до змінної якій присвоєний масив об'єктів .find (ф-ція яка виконується для кожного елементу масива(item - елемент масиву, index - ключ/позиція, array - весь масив ))
let resultOne = arrFind.find(function(item, index, array){
  return item.name === 'dinorik';
  return item.age === 14;
});
//Теж саме за допомогою стрілкової ф-ції
// let resultOne = arrFind.find(item => item.name ==='dinorik'); // Object { name: "dinorik", age: "Не скажу" }
console.log(resultOne); // Object { name: "dinorik", age: "Не скажу" }

//findIndex
let resultTwo = arrFind.findIndex(item => item.age === 14);
console.log(resultTwo); // 0

let resultThree = arrFind.findIndex(item => item.name === 'pizhma');
console.log(resultThree); // 1

_________________________________________________________________________
//Пошук в масиві

// filter
//Шукає всі елементи, на яких ф-ція-колбек поверне true.Схожий на метод find, але не припиняє свою роботу в той момент коли задоволена задана умова. А продовжує її і повертає новий масив із всіх елементів які задовольняють вказану умову
/*Синтаксис:
 let result = arr.filter(function(item, index, array){
  якщо true - елемент додається до р-тату, і перебір продовжується
  якщо нічього не знайдено, повертається порожній масив
}); */

 let arrFilter = [
  { name: 'pypurka', age: 18 },
  { name: 'pyp', age: 23 },
  { name: 'raksakorikorfalapatoriys', age: 'Дофіга' },
]

// let resultFilter = arrFilter.filter(function(item, index, array) {
//   return item.age >= 18;
// });
//Коротший запис стрілковою ф-цією
let resultFilter = arrFilter.filter(item => item.age === 18);
console.log(resultFilter);  //Object { name: "pypurka", age: 18 }

//Фільтрація малих значень
function num (value) {
  return value >= 100;
}

let filterArr = [12, 6, 13, 135, 148, 119, 7].filter(num);
console.log(filterArr); //Array(3) [ 135, 148, 119 ]
//всі числа які не задовольняли умову ф-ції num будуть видалені з масиву 


//Пошук простих чисел в масиві
//Я не розумію як це працює (((
const array = [-3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];
function isPrime (num) {
  for (let i = 2; num > i; i++) {
    if (num % i == 0) {
      return false;
    }
  }
  return num > 1;
}

console.log(array.filter(isPrime)); //Array(6) [ 2, 3, 5, 7, 11, 13  */
___________________________________________________________________________
//Сортування масивів
//Метод sort(fn) - змінює в масиві порядок елементів .Схоже на метод  reverse

/* //Сортування слів
let arrOne1 = ['Ваня', 'Іван', 'Оля'];
console.log(arrOne1.sort()); //Array(3) [ "Іван", "Ваня", "Оля" ] */

//Сортування чисел
let arrTwo2 = [8, 22, 1];
console.log(arrTwo2.sort()); //Array(3) [ 1, 22, 8 ]

/* За замовчуванням елементи сорторуються як рядки , для яких використовується лексикографічний порядок  
console.log('8' > '22'); // true */

//В момент виклику метода sort в () можна вказувати ім'я ф-ції яка буде враховуватись при виконанні сортування

//Ф-ція сортування
// function compareNumeric (a, b) {
//   console.log(`Порівнюємо ${a} і ${b}`);
//    if (a > b) return 1;  
//   if (a == b) return 0;
//   if (a < b) return -1; */
/*   Оскільки в даному випадку достатньо повертати позитивне або негативне число  або 0 , то замість запису вищє можнав використати  повернення результату виразу віднімання
return a - b;  //Array(3) [ 1, 8, 22 ] */

// }
// console.log(arrTwo2.sort(compareNumeric));  //Array(3) [ 1, 8, 22 ]
                                           // Порівнюємо 1 і 22
                                           //Порівнюємо 22 і 8
                                           // Порівнюємо 1 і 8

//Або можна вирішити всю задачу використовуючи стрілкову ф-цію і в () метода sort написати ф-ція яка буде виконувати все те саме
console.log(arrTwo2.sort((a, b) => a-b)); //  Array(3) [ 1, 8, 22 ]
//В р-таті ми отримуємо правильно відсортований масив чисел

_________________________________________________________________________
//Сортування масивів
//Метод reverse - змінює порядок елементів на зворотній
let arrThree3 = ['Ваня', 'Іван', 'Оля'];
console.log(arrThree3.reverse()); //Array(3) [ "Оля", "Іван", "Ваня" ]

_________________________________________________________________________
//Перетворення масивів
//Метод map - викликає ф-цію для кожного елементу масива і повертає масив р-татів виконання цієї ф-ції
//В тілі ф-ції можна виконувати певний код і повертати р-тати які сформують значення нового масиву

/* Синтаксис:
let result = arr.map(function(item, index, array){
  //Повертає нове значення замість елемента
}); */

let arrMap = ['Ваня', 'Іван', 'Оля'];

let resultMap = arrMap.map(function(item, index, array){
  return item[0]; //Повертає першу букву кожного елементу "В", "І", "О"
});
console.log(arrMap); //Array(3) [ "Ваня", "Іван", "Оля" ] масив не змінився
console.log(resultMap); // новий масив Array(3) [ "В", "І", "О" ]
_________________________________________________________________________
//Перетворення масивів
//Методи split i join
/* Метод split перетворює рядок в масив по заданому розділювачю
Синтаксис: 
str.split(delim)  */ 

let strSplit = 'Ваня, Іван, Оля';

let arrSplit = strSplit.split(','); //Звертаємось до рядка strSplit ставимо '.' пишемо split і в ('') вказуємо розділювач, в даному випадку це ','
console.log(arrSplit); //Отримуємо масив із цих елементів :Array(3) [ "Ваня", " Іван", " Оля" ]

//Можна обмежити к-ть об'єктів які потраплять в масив, через ',' вказавши потрібну к-ть
let arrSplitOne = strSplit.split(',', 2);
console.log(arrSplitOne); //Array [ "Ваня", " Іван" ]

/* Метод join перетворює масив в рядок по заданому розділювачю, який може бути чим завгодно
Синтаксис:
arr.join(glue) */

let arrJoin = ['Ваня', 'Іван', 'Оля'];
let strJoin = arrJoin.join(',');
console.log(strJoin); // Ваня,Іван,Оля

//Отримання рядка із масиву ф-цією String, р-тат буде тимже
//Але при промтому переводі в рядок не можна вказати розділювач і він завжди буде ','
let arrJoinOne = ['Ваня', 'Іван', 'Оля'];
console.log(String(arrJoinOne)); // Ваня,Іван,Оля
_________________________________________________________________________
//Перевірка Array.isArray()
// Масиви не являються окремим типом даних, вони основані на об'єктах

let obj = {};
let arr = [];

console.log(typeof obj); // object
console.log(typeof arr); // object

//Щоб дізнатись де масив, а де ні існує перевірка Array.isArray()
//Синтаксис:
if (Array.isArray(arr)) {
  console.log('Це масив!');
} else {
  console.log('Це не масив!');
}
//В () вказуємо змінну якій присвоєно масив і якщо це дійсно він повернеться true,якщо ні, то повернеться false
___________________________________________________________________________
//Перебір елементів 
let arr = ['Ваня', 'Іван', 'Оля'];
console.log(arr.length); //3

//Цикл FOR
//Можна отримати значення і ключ масиву
//Оголошуємо змінну 'і' яка рівна 0, збільшуємо кожен раз її на одиницю і в якості умови 'і' має бути менше ніж довжина масиву
for (let i = 0; i < arr.length; i++){
  console.log(arr[i]); // Якщо потрібно вивести кожне значення масиву, потрібно звернутись до змінної якій присвоєний масив і в [] вказати змінну 'і'
}
//Ключі починаються з 0, перше значення змінної 'і' також 0, і з кожним колом ітерації воно буде збільшуватись на одиницю, поки 'і' не буде рівна length.
//На першому колі 'і' буде рівна 0, відповідно виведеться перше значення масиву. На дркгому колі = 1, друге значення масиву. На третьому колі = 2, третє значення масиву і на четвертому колі 'і' = 3 , умова не спрацює і цикл зупинить свою роботу
_________________________________________________________________________
//Перебір елементів 
//Цикл FOR...OF
//Можна використовувати тільки для виведення значень

let arr = ['Ваня', 'Іван', 'Оля'];

//Оголошуємо змінну яка буде мати в собі кожне значення масиву, пишемо of і змінну яка містить в собі масив
for (let arrItem of arr) {
  console.log(arrItem); //Виводимо в консоль нову створенну змінну, таким чином ми отримуємо значення масиву
}
____________________________________________________________
//Перебір елементів 
// Метод forEach - виконує ф-цію для кожного елемента масиву
/* Синтаксис:
arr.forEach(function(item, index, array){
  //робить щось з item
}); */

let arr = ['Ваня', 'Іван', 'Оля'];

//В тілі ф-ції з аргументами можна робити що завгодно, виконувати певні дії, виводити на екран або працювати з ними
/* arr.forEach(function(item, index, array){
  console.log(`${item} знаходиться на ${index} позиції в ${array}`); 
  // Ваня знаходиться на 0 позиції в Ваня,Іван,Оля
  // Іван знаходиться на 1 позиції в Ваня,Іван,Оля
  // Оля знаходиться на 2 позиції в Ваня,Іван,Оля
});
 */

//Даний запис можна спростити за допомогою стрілкової ф-ції
arr.forEach((item, index, array) => {
   console.log(`${item} знаходиться на ${index} позиції в ${array}`);
});

//Також при використання метода forEach можна вказувати просто ім'я окремої ф-ції і все буде працювати точно так

/* arr.forEach(show);

function show (item) {
  console.log(item);
} */
___________________________________________________________________________
//Методи reduce/reduceRight

/* Якзщо потрібно перебрати масив - можна використовувати forEach, for або for...of . Якщо потрібно перебрати масив і повернути дані для кожного елемента - метод map

Методи arr.reduce і arr.reduceRight схожі на ці методи, але вони трохи складніші і використовуються для вичислення якогось єдиного значення на основі всього масиву
 */

Синтаксис:
let value = arr.reduce(function(previousValue, item, index, array){
  //....
}, [initial]);

/* До звичних аргументів додається previousValue:
  initial - початкове значення, записано другим параметром reduce
  previousValue - приймає р-тат попереднього виклику ф-ції, рівний початковому значенню (initial) при першому виклику (якщо переданий initial), 
  item - елемент масиву,
  index - його індекс,
  array - сам масив.

  Ф-ція застосовується по черзі до всіх елементів масиву і переносить свій р-тат на наступний виклик. */

  let arrReduce = [1, 2, 3, 4];
  let reduceValueOne = arrReduce.reduce(function(previousValue, item, index, array){
    return item + previousValue; //Сума поточного значення масиву [1, 2, 3, 4], з попереднім previousValue
  }, 0); //0 Початкове значення для previousValue

  console.log(reduceValueOne); //10

  /* 
   Крок №1 
  previousValue = 0;
  item = 1;
  Їх сума = 1;

   Крок №2
  previousValue = 1;
  item = 2;
  Їх сума = 3;

   Крок №3
  previousValue = 3;
  item = 3;
  Їх сума = 6;

   Крок №4
  previousValue = 6;
  item = 4;
  Їх сума = 10;
  */


  //Якщо не вказати початкове значення, то воно буде дорівнювати першому елементу масива(previousValue = Ваня), а робота метода почнеться з другого елемента (item = Іван)

let arrName = ['Ваня', 'Іван', 'Оля'];
let reduceValueTwo = arrName.reduce(function(previousValue, item, index, array){
    console.log(previousValue); //Ваня
    console.log(item); // Іван
    return `${item}, ${previousValue}`; //Іван, Ваня
});
console.log(`Користувачі: ${reduceValueTwo}`); // Користувачі: Оля, Іван, Ваня

//Метод reduceRight працює аналогічно, але проходить по масиву справа на ліво
___________________________________________________________________________
//Масив використовуєм як масив
//Масив являється об'єктом і поводить себе як об'єкт

let arr = ['Ваня', 'Іван', 'Оля'];

//Додаємо нечислову властивість
arr.name = "Колян";
console.log(arr); //Array(3) [ "Ваня", "Іван", "Оля", name: "Колян" ]

/* 
Масиви робить особливим їхнє внутрішнє уявлення. Движок JS старається зберігати елементи масива в безперервній області пам'яті, один за одним. Існують і інші способи оптимізації, завдяки яким масиви працюють дуже швидко.
Але всі вони втратять ефективність, якщо перестати працювати з масивами як з "впорядкованою колекцією даних" і почати використовувати їх як звичайні об'єкти.

Варіанти неправильного використання масива:
1. Додавання нечислових властивостей : arr.test = 5.
2. Створення дірок : додавання arr[0],потім arr[1000](між ними нічього немає)
3. Заповнення масиву в зворотньому порядку: arr[1000], arr[999] і.т.д
Все призведе до зменшення швидкості масиву
*/
______________________________________________________________________-