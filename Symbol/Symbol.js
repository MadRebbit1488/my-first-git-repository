/* 
Теми:
- .toString() / symbol.description 
- Symbol.for(key) / Symbol.keyFor(key)
-  Object.getOwnPropertySymbols(obj)  / Reflect.ownKeys(obj),*/

/* Символ - це примітивний тип даних, який використовують для створення унікальних ідентифікаторів. Навіть якщо створити багато символів з однаковим описом, це всеодно будуть різні символи. 
Опис - це просто мітка яка нінащо не впливає 

Символи мають два основні варіанти використання:
- Це приховані властивості об'єкта
- Для зміни вбудованої поведінки об'єкта
Створюються символи за допомогою ф-ції Symbol(ім'я) і задати йомі ім'я, в основному використовується для отладки коду*/
let id = Symbol('id');

//Сиволи з однаковим описом
let id1 = Symbol('id');
let id2 = Symbol('id');
console.log(id1 == id2); //false
console.log(id1 === id2); //false

//Практично всі дані в JS при виклику перетворюються в рядок, символи особливі і не перетворюються автоматично. Це захист від плутанити, адже рядки і символи - різні типи даних і не повинні неконтрольовано перетворюватись один в одного. 
let id3 = Symbol('id');
alert(id3); //peError: 
//Якщо потрібно вивести символ за допомогою alert, то його потрібно явно перетворювати за допомогою методу .toString()
let id4 = Symbol('id');
alert(id4.toString()); //Symbol(id)
//Або звернутись до властивості symbol.description, щоб вивести тільки опис
let id5 = Symbol('id');
alert(id5.description); //id
______
//Приховані властивості
/* Символи дозволяють створювати приховані властивості об'єктів, до яких неможна випадково звернутись і перезаписати із інших частин програми */

//Наприклад є користувач і потрібно додати до нього ідентифікатор
let userS = {
  name: 'Pypa',
};
let id6 = Symbol('id');
userS[id6] = 1;
console.log(userS[id6]); //1 ,можна отримати дані по ключю симвалу
/* Якщо користувач належить до сторонього коду, то не варто додавати до нього якісь поля. Це небезпечно. Але до символа важко звернутись випадково і сторонній код його наврядчи його взагалі побачить, і додавання поля до об'єкта не викличе ніяких проблем.
До того ж можна допустити, що інший скрипт для своєї мети хочє записати власний ідентифікатор в користувача, цей скрипт ніяк не повязаний з нашим. І він може створити свій символ Symbol("id").
Конфлікту між нашим і стороннім ідентифікатором не буде, так як символи завжди унікальні.
Але якщо використовувати рядок 'id' замість символа, тоді буде конфлік*/

//Символи в літералі об'єкта
/* Якщо потрібно викор символ при літеральному оголошені, то потрібно помістити його [] */
let id7 = Symbol('id');
let userId = {
  name: 'Pypa',
  [id]: 1488, // Просто id: 1488 не спрацює
};
//Це викликано тим, що потрібно використовувати значення змінної 'id' в якості ключа, а не рядок 'id'
______
//Символи ігноруються циклом for…in
let id8 = Symbol('id');
let userI = {
  name: 'Pypa',
  age: 24,
  [id8]: 1488,
};
for (let key in userI) {
  console.log(key); //name, age
}
//Але напряму досту до символу працює
console.log('Напряму: '+ userI[id8]); //Напряму: 1488
/* Це потрібно для того, щоб інша бібліотека або скрипт не отримали доступ до симольногої властивості */

______
//Object.assign - копіює символьні властивості
let id9 = Symbol('id');
let userID = {
  [id9]: 1488,
};
let clone = Object.assign({}, userID);
console.log(clone[id9]); //1488
/* Ідея в тому, що коли клонуються або об'єднуються об'єкти, копіюються всі властивості */

__________________
//Глобальні символи - ті які містяться в глобальному реєстрі, використовуються тоді, коли потрібен символ доступний кругом в коді

/* Глобальний реєстр символів - дає змогу різним частинам програми отримвати доступ до символу "id, маючи наувазі під ним одну і туж властивість.
Дає змогу створювати рівні один одному однойменні символи.
Тобто в ньому можна створювати символи і звертатись до них пізніше і при кожному зверненні буде гарантовано повертатись один і той же символ */

______
//Symbol.for(key) 
//Шукає символ по імені
/* Використовується для читання символа. Він первіряє глобальний реєстр і при наявності в ньому символа з іменем key, повертає його, або створює новий символ і записує в реєстр під ключем key*/

//Читаємо символ із глобального реєстра і записуємо його в змінну
//Якщо символа не існує, він буде створений 
let id10 = Symbol.for('id');
//Читаємо його знову і записуємо в іншу змінну(можливо із іншого місця коду)
let idAgain = Symbol.for('id');
//Перевіряємо чи це один і тойже символ
console.log(id10 === idAgain); //true

______
//Symbol.keyFor
/* Приймає глобальний символ і повертає його ім'я. */
//Отримуємо символ по імені
let sym = Symbol.for('name');
//Отримуємо ім'я по символу
console.log(Symbol.keyFor(sym)); //name

/*  Якщо символ не глобальний поверне undefined. Так як працює тільки з глобальним реєстром.
Але можна отримати доступ до будь якого символа через властивість description */
let globalSymbol = Symbol.for('name');
let localSymbol = Symbol('name');
console.log(Symbol.keyFor(globalSymbol)); //name
console.log(Symbol.keyFor(localSymbol)); //undefined
console.log(localSymbol.description); //name

______
 //Object.getOwnPropertySymbols(obj) - з його допомогою можна отримати всі властивості об'єкта з ключами-символами.
 //Майже не використовується
______
//Reflect.ownKeys(obj) - повертає всі ключі об'єкта, включно із символьними
 //Майже не використовується
______
/* Символи можна використовувати щоб налаштовувати різноманітні аспекти поведінки об'єктів.
Ці символи перечислені в специфікації в таблиці  Well-known symbols:
-Symbol.hasInstance
-Symbol.isConcatSpreadable
-Symbol.iterator
-Symbol.toPrimitive
…і так далі. */