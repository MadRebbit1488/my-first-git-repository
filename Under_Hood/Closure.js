//console.dir

//Замикання   !!!Можуть запитувати на співбесіді
function changeBalance() {
  let balance = 0;
  return function (sum) {
    balance += sum;
    console.log(`Баланс: ${balance}`);
  }
}

//Тепер change це вищє описана ф-ція. Яка приймає суму і нічього не повертає, але змінює баланс
const change = changeBalance();
change(100); //Баланс: 100
change(-50); //Баланс: 50
change(200); //Баланс: 250
/* Не дивлячись на те, що ф-ція знаходиться в глобальному контексті нам всеодно вдається змінювати баланс і більш того від виклику до виклику баланс зберігається і ми можемо змінювати його*/

//Не рекомендується використовувати на проді
//Виводить всі властивості об'єкта, включаючи ті з якими не можна взаємодіяти на пряму
console.dir(change);//[[Scopes]]: Scopes[3] 0: Closure (changeBalance) {balance: 250}

const change2 = changeBalance();
change2(100); //Баланс: 100
console.dir(change2);//[[Scopes]]: Scopes[3] 0: Closure (changeBalance) {balance: 100}
//Створюючи нову ф-цію ми фіксуємо за нею  все оточення в якому ця ф-ція була оголошена

//Розглянемо покроково як працює замикання:
/*
  - Крок 1:
*Stack містить тільки глобальний контекст
Показує виконання контексту, який контекст зараз активний
*Scope 
Global
- changeBalance  
- change 
Показує як відбувається наслідування скоупів, завдяки чьому ми маємо доступ до змінних батьківського скоупу
Все розкладено, починаємо виконувати код з оголошення ф-ції


  - Крок 2:
Виконуємо ф-цію changeBalance
*Stack:
      -changeBalance() містить баланс 
        - balance за замовчуванням рівний 0
Ф-ція changeBalance при виконанні оголошує баланс і повертає нову ф-цію, на цьому виконання ф-ції changeBalance закінчується

  Global

*Scope:
Global
  -changeBalance() 
    - change

            changeBalance() 
              - balance 

  - Крок 3:
Викликаємо change
changeBalance по завершенню виконання йде із Stack, фактично зникає і чисто теоритично більше не існує. Замість цього на Stack поміщяється ф-ція change
*Stack:
    -change() має збільшити баланс на 100

  Global    
*Scope в глобального контексту з'являється щє один дочірній
        Global:
            -changeBalance() 
                - change
Children of the global:
change  ----------------------changeBalance() 
  -sum                            - balance 

change змінив balance не дивлячись на те, що вони на одному рівні і ні один із них не являється дочірнім чи батьківським іншого, а тільки дочірні для Global. 
change не змінив баланс, він змінив баланс який знаходиться в рамках замикання.

Коли ми викликаємо change і змінюємо баланс ,у нас із контексту який пішов після виконання ф-ції changeBalance, balance завжди присутній в рамках контексту change і саме зв'язок того оточення де була створена ф-ція і change являється замиканням. По суті коли ми викликаємо change він за собою носить цей контекст. І коли ми викликаємо change він знає що баланс існує через контекст ф-ції changeBalance. Це додатковий скоуп який присутній у ф-ції, саме ця механіка і називається замиканням
change  ----------------------changeBalance() 
  -sum                            - balance 
Самостійно управляти замиканням ми не можемо, так як це внутрішня механіка яка працює під капотом
Зовні до balance який знаходиться в замиканні ми достукатись не можемо. Єдиний хто має до нього доступ це change, тому що баланс супутній ф-ції change розом із замиканням

Замикання - це комбінація ф-цій і лексичного оточення, в якому ця ф-ція була оприділена. Внутрішня механіка яка працює під капотом
Тобто ф-ція пам'ятає, в якому контексті вона була створена і може його використовувати
В нашому випадку лексичне оточення ф-ції change це ф-ція changeBalance. Вона знає все і зберігає пам'ять про контекст в якому вона була створена
Ф-ція change коли створюється кладе собі за позуху весь контекст ф-ції changeBalance. Тому вона може достукатись до balance і до аргументів. Тому оточення ф-ції changeBalance стає нерозривною частиною новоствореної ф-ції change і відповідно ми можемо її змінювати

! Замикання має біль високий пріорітет в порівнянні з глобальними змінними батьківських scope

Наприклад якщо в глобальному контексті оголосити щє якийсь баланс, то він зміненим не буде. Тому що перед тим як шукати в свої скоуп чейнах ф-ція change спочатку подивитись своє замикання і якщо в замиканні є ця змінна вона буде змінена, якщо ні то вона піде далі по ланцьогу шукати цей баланс зовні.

Якщо створити щє одну ф-цію і прив'язати до неї changeBalance розом з контекстом, вона не буде зв'язана з першим ставореним change
*/


_________________________________________________________________
//про замикання із іншого джерела

/* 
Замикання - це ф-ція всередині іншої ф-ції */

function createCalcFunction(n) {
  return function() {
    console.log(1000 * n);
  }
}

//Сама пособі ф-ція нічього не поверне так як вона повертає ф-цію
createCalcFunction(42);
//calc - це ф-ція яку ми отримуємо із іншої ф-ції
const calc = createCalcFunction(42);
console.log(calc); //ƒ () {console.log(1000 * n);}
calc(); //42000
/* Коли ми викликали ф-цію createCalcFunction і передали їй аргумент 42, то ф-ція відпрацювала повернувши нам нову ф-цію. Але враховуючи що анонімна ф-ція була викликана в контексті createCalcFunction, змінна n замкнута в тій ф-ції яку ми повертаємо. І тому коли ми викликаємо ф-цію calc в ній вже зберігається значення n. Тобто ми отримуємо доступ до скоупа верхньої ф-ції.*/

//
function createIncrementor(n) {
  //Повертає суму двух чисел
  return function(num) {
    return n + num;
  }
}
//Замикаємо змінну n на значенні 1
//Ф-ція addOne замкнула в собі значення 1 і додає його до всіх аргументів змінної num
const addOne = createIncrementor(1);
const addTen = createIncrementor(10);

console.log(addOne(10)); //11
console.log(addOne(41)); //42

console.log(addTen(10)); //20
console.log(addTen(41)); //51
/* По суті ми використовуємо одну ф-цію createIncrementor(1) де замикаємо певне значення, на виході ми отримуємо іншу ф-цію яка може працювати з іншими параметрами*/

//
function urlGenerator(domain) {
  return function(url) {
    return `https://${url}.${domain}`;
  }
}
const comUrl = urlGenerator('com');
console.log(comUrl('google')); //https://google.com
console.log(comUrl('youtube')); //https://youtube.com

const uaUrl = urlGenerator('ua');
console.log(uaUrl('google')); //https://google.ua
console.log(uaUrl('youtube')) //https://youtube.ua

