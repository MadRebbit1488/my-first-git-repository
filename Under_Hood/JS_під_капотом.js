/* 
Теми:
-Контекст виконання і stack виклику (Call Stack) 
-SCOPE(Область видимості)
- Підняття(Спливання) 
- THIS / контекст this в методах ->дивитись файл this.js
- ARGUMENTS
 */

/*
JS - компілюється а не інтерпретується
Виконанням JS скрипта є движок який обробляє код, перетворює його в байт-код і вже цей байт-код виконує.
Движків є декілька, вони залежать від браузера і середовища виконання:
 - V8 - Chrome
 - SpiderMonkey - відноситься до FireFox
 - JavaScriptCore - Safari
 
 *Компіляція - вихідний код => файл машинного коду => виконання(тобто ми скомпілювали і відправили  і коли нам потрібно виконати машинний код він виконується)
 *Інтерпретація - вихідний код => виконання
 *JIT - вихідний код => машинний код => виконання (тобто компілюємо => виконуємо)*/

 /* Робота движка під капотом: 
 1. Є вихідний файл JS code
 2. JS code перетворюється в AST(абстрактне синтаксичне дерево) - це представлення коду, яке зручне для сприйняття машини.Тобто це дерево яке описує код по рядках, по буквах
 3. Потім цей код компілюється в байт-код -> машинний код
  +Оптимізація
 4. Виконується
  +Оптимізація*/

  /*Середовищє виконання JS 
  1.Движок JS:
  * Call Stack
  * Heap

  2.WEB APIs / Node:
  *DOM
  *Timers
  *Fetch
  *GEO

  3.Callback Queue*/

__________
  /* Контекст виконання і stack виклику (Call Stack) 
  Контекст виконання:
  1. Створюється глобальний контекст (контекст - це коробка в яку ми кладемо все що буде в ньому знаходитись: змінні, ф-ції)

  2. Виконання кода верхнього рівня(код який не завернутий в ф-ції, це поточний файл який виконується зверху до низу
  const user = {
    name: 'Pypa',
    roles: ['admin'],
  };
  function isUserAdmin (user) {
    return user.roles.includes('admin');
  }
  console.log(isUserAdmin(user)); //true
 взяли користувача поклали в контекст, ф-цію поклали в контекст, тобто в глобальному контексті буде декілька об'єкті.)

 3. Виконання ф-ції і очікування callback
 
 В середині контексту знаходиться три блоки:
 1. Оточення змінних
  - let, const, var
  - function
  - arguments
2. Scope Chains - силки на змінні поза поточним контекстом
3. This - посилається на поточний контекст (стрілкові ф-ції не мають свого this) 
 */


/* Stack - це певна послідовність з якою викликається код.*/
const a = 5;
function double (a) {
  return a * a; 
}
function logDouble (a) {
  console.log(double(a));
}
console.log(`Старе значення ${a}`); //Старе значення 5
logDouble(a); //25

/* 
-Глобальний контекст містить:
 const a = 5
 double () - ф-ція
 logDouble () - ф-ція
 console.log() - ф-ція яка відразу виконується і виводить значення 5
 logDouble () - виклик ф-ції 
 Після виконання ф-ції logDouble () ми провалюємось в новий контекст
 -Контекст ф-ції logDouble ():
 logDouble ()
 console.log() - містиь в собі double ()
 Провалюємось в контекст ф-ції double ()
 - Контекст ф-ції double ()
 Після закінчення виконання ф-ції double () її контекст зникне.
 Тому що після завершення виконання ф-ції зникає її контекст.
 Потім ми виводими в консоль те що мала вивести ф-ція double ()
 Далі припиняється виконання ф-ції logDouble () цей контекст іде і ми провалюємось в глобальний  контекст

Тому це і називається Stack викликів,тому що вони стекаються один на одному.
Завдяки такій стековій будові у JS немає змоги загубитись, так як ми послідовно ідемо по коду і як тільки ми потрапляємо в новий контекст, старий контекст зупиняється.
 */

//Приклад роботи Call Stack
 const sum = 1;
 console.log('start'); //start
 console.log(sum); //1
 //Ф-ція додати 5
 function add5 (n) {
  n = n + 5;
  if (n > 10) {
    //Якщо n > 10, то ми зупиняємось і видаємо n
    return n;
  }
  console.log(n);
  //Якщо n < 10 то в р-таті ми викликаємо себе ж вже з новим аргументом збільшеним на 5
  return add5(n);
 }
 add5(sum); //6
 console.log('ended'); //ended


 ________________________________________________
//SCOPE(Область видимості) and THIS
/* Scope chains - силка на змінну поза поточним контекстом, тобто ц силки на інші області видимості
В JS використовується лексичний scope, тобто оглошуючи змінну всередині ф-ції ми поміщяємо її в scope цієї ф-ції 
SCOPE - це область видимосі і наслідуівння області видимості
Існує 3 види scope:
1. Глобальний scope - поза будь-який ф-ції чи блоків. Змінні доступні кругом 
(const b = 10;)
2. Scope ф-ції - змінн доступні тільки всередині ф-ції 
(function a () {const c = 5;})
3. Блочний scope - змінні доступні тільки всередині блоку 
if (b < 10) {const d = 'Yes';}*/

// Особливості VAR
/* Не обмежується блочним scope, змінна в блоці буде доступна глобально */

//SCOPE CHAIN
/* Зверненні із дочірніх SCOPE в батьківські. Як це відбувається */
const initialValue = 1;

function createArray (value) {
  const message = 'Повідомлення';
  function createOne (val) {
    const arr = [val, message];
    return arr;
  }

  if (value < 0) {
    const val = 0;
    var i = 9;
    return createOne(val);
  }
  return createOne(value);
}
createArray(initialValue);
console.log(createArray(initialValue));  //[1, 'Повідомлення']
/* В нас є змінна 'initialValue' і ф-ція 'createArray' ми викликаємо ф-цію, передаючи їй змінну 'createArray(initialValue)'
І в ф-ції 'createArray' є ф-ція 'createOne' яка звертається до 'message' який знаходиться не в ОВ createOne а в ОВ 'createArray'
Як це працює6
Глобальний 'SCOPE':  
  - initialValue
  - createArray
Другий 'SCOPE' утворюється коли ми викликаємо 'createArray'
  - message
  - createOne
  - value аргументи ф-ції знаходяться в рамках свого SCOPE
  - 'i' за рахунок 'var' вона протікає на 'SCOPE' вищє і в ОВ 'createArray' вона стає доступна
ОВ createOne:
  - arr
  - val аргумент ф-ції 
ОВ if():
  - val
'і' перетік в ОВ createArray

Код працює не дивлячись на те, що ф-ції 'createOne' звертається до 'message' який знаходиться в батьківському 'SCOPE' 'createArray'
Як це працює:
Коли ми звертаємось з 'createOne':
- Ми можемо звертутись до всіх елементів які знаходяться всередині 'createOne'
- До всіх батьківських елементів 'createArray'
- До батьківського SCOPE батьківського SCOPE і по всьому ланцюгу до самого глобального SCOPE */


//Різниця між SCOPE та Call Stack
/* Стек виконання ніяк не пов'язаний із скоупінгом
Якщо ф-ція вкладена в іншу ф-цію, необов'язково дочірня буде викликатись із батьківської. І тоді це буде не послідовний виклик і стек не буде рівний скоупу
Приклад:
function one () {
  function two () {
    three ();
  }
  two();
}
function three () {
}
one(); <- виклик

Глобальтний скоуп:
  - one
  - three
Викликаємо one, всередині неї є ф-ція two, яка оголошена всередині one.
Всередині two є ф-ція three

Логіка Call Stack:
global -> one -> two -> three

Scope буде іншим:
- глобальний Scope
- ф-ція one і ф-ція three
- У one є ф-ція two
Тобто 
two -> one -> global
three -> global
  */

________________________________________________

//Приклади Scope Chain
let successMessage = 'Success';
const user = {
  name: 'Lolo',
  roles: [],
} 
//Ф-ція додає роль користувачю
function addRole (user, role) {
  if (role == 'admin') {
    const message = 'Error';
    console.log(message);
    //console.log(a); <- Викличе помилку, так як оголошенна змінна знаходиться в іншому контексті, із яким контекст if() не пересікається
    return user;
  }
  user.roles.push(role);
  //successMessage = 'Yiiii'; <- Змінили значення змінної, так як вона в глобальному контексті
  //let successMessage = 'Yra'; <- якщо переоголосити глобальну змінну локально, вона буде вважатись новою. Присвоєне їй нове значення не буде змінювати глобальну змінну і залишиться в мвоєму контексті і контекст буде надавати перевагу внутрішній змінній
  console.log(successMessage);

  function logRoles () {
    //const a = 3; <- викличе помилку якщо викликати поза контекстом
    console.log(user.roles); //['dev']
  }
  logRoles();

  return user;
}
//console.log(addRole(user, 'admin')); //Error
console.log(addRole(user, 'dev')); //{name: 'Lolo', roles: ['dev']}
/* Блоки Scope навіть якщо знаходяться на одному рівні і мають спільний батьківський Scope, контекстами не пересікаються. В даному прикладі це if() i logRoles(). Знаходяться на одному рівні, але мають різні контексти*/
 

________________________________________________
//Підняття
/* Підняття - це мождивість використовувати певні типи змінних до того, як вони були оголошені: 
- ф-ції - початкове значення сама ф-ція
-  var - початкове значення undefined, тому що підніметься тільки оголошення , а присвоєння підійматись не буде

До let i const не можна зверутись до їх оголошення, це викличе помилку
Тобто при оголошенні let i const зміна не підіймається і початкове значення буде initialized. Тобто вона щє не ініційована і розміщаєбся в Temporal dead zone.
function addRole() {
  user.roles.push(role);  додаємо роль      <----- TDZ
  let successMessage = 'Ypa';               <----- 
  const role = 'test';   <- оголошена роль
  Все до оголошення цієї константи буде для неї TDZ, вищє вона не доступна
}
Тобто це мертва зона де змінна не доступна .JS розуміє що буде далі але ми не можемо її використати і викине помилку

В стрілкових ф-ціях все залежить від оголошення:
 - Якщо оголосити як var вона буде себе поводити відповідно var.
 - Якщо оголосити як let i const вона підійматись не буде

 Викинути var не можна, так як JS має бути зворотньо сумісний для підтримання всіх попередніх версій

 Ф-ції осознано зроблені спливаючими і підіймаючимися. Так як це вирішує проблему взаємної роботи двох ф-цій при оголошенні
*/


//Приклади підняття
addUser(); //User added
//console.log(e); //ReferenceError: 
console.log(b); //undefined
const e = 3;
var b = 2;
console.log(b); //2
function addUser () {
  console.log('User added'); //ф-цію можна викликати як до так і після оголошення
}
arr1(); //TypeError
//Що відбувається:частина var arr1 спливла, але якщо її викликати , то це не ф-ція і буде на цьому моменті undefined і ми не можемо до неї достукатись
var arr1 =  () => {
  console.log('arr1');
}
addUser(); //User added
__________
//ARGUMENTS
/* Контекст складається із 3 складових:
- let, const, var, func, arguments
- Scope Chain
- This

Arguments - це не тільки аргументи ф-ції, але і спеціальний об'єкт
*/
/* Ф-ція має аргументи num1, num2, які ми сумуємо. Також вона має своє this яке має значення undefined . А такоє спеціальний об'єкт arguments який містить аргументи нашої ф-ції
Насправді мажна викликати ф-цію з більшим числом аргументів, прицьому ф-ція не зламається, тому що ф-ція приймає два аргумента, вони працюють все класно. Але ARGUMENTS буде мати всі аргументи з якими вона була викликана
Інколи використовується для того, щоб знати всі аргументи які передаються і інколи робити якісь модифікації(варто робити локально)*/
function sumNum (num1, num2) {
  console.log(this); //undefined
  console.log(arguments); //Arguments(4) [1, 3, 5, 8, callee: (...), Symbol(Symbol.iterator): ƒ](Symbol.iterator): ƒ]
  //Можна отримати конкретрний аргумент
  console.log(arguments[0]); //1

  return num1 + num2;
}
console.log(sumNum(1, 3, 5, 8 )); //4

//Аргументи поводять себе по різному, взалежності від того звичайна це ф-ція чи стрілкова ARGUMENTS немає
//В стрілкових ф-ціях 
const sumNumArr = (num1, num2) => {
  console.log(this); //Window {window: Window...
  console.log(arguments);  // не оприділений
  return num1 + num2;
}
console.log(sumNumArr(1, 3, 5, 8 )); //ReferenceError: 
//В стрілковій ф-ції не можна отримати аргументи і якось ними маніпулювати
