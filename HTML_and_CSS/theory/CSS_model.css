/* Макет
*Блочні елементи
*Вбудовані рядкові елементи
*display - визначає як має відображатися елемент
Властивості: none, inline ,block
*visibility:hidden; - визначає чи повинен елемент бути видимим
*max-width - покращує роботу браузера з невеликими вікнами
*Position - визначає тип метода позиціонування, що використовується для елемента
    *static - статичний
    *relative - відносний
    *fixed - фіксований
    *absolute - абсолютний
    *sticky - закріплений


*clip - Закріплює абсолютно позиціонований елемент
*z-index - визначає порядок стека елемента

*Overflow - визначає, що відбувається, якщо зміст переповнює поле елемента
    *visible - за замовчуванням. Переповнення не обрізається. Контент відображається поза полем елемента
    *hidden - переповнення обрізається(приховується), а інша частина змісту буде невидимою
    *scroll - переповнення обрізається, і додається смуга прокрутки, щоб побачити іншу частину змісту
    *auto - аналошічно scroll, але додається смуга прокрутки лише при необхідності
    *overflow-x вказує, що робити з лівим/правим краєм змісту, якщо воно виходить за межі області змісту елемента
    *overflow-y вказує, що робити з верхнім/нижнім краєм змісту,якщо воно виходить за межі області змісту елемента


* float - використовується для позиціонування та форматування змісту, коли зображення розташовується зліва від тексту в контейнері
    Значення: 
      *left - Елемент плаває зліва від свого контейнера.
      *right - Елемент плаває справа від свого контейнера.
      *none - Елемент не плаває (буде відображатися саме там, де він зустрічається в тексті). Це за замовчуванням
      *inherit - Елемент наслідує float-значення свого предка
* clear - визначає які елементи можуть плавати поруч із очищеним елементом і з якого боку
      Значення: 
      *none - допускає плаваючи елементи з обох боків. Це за замовчуванням
      *left - з лівого боку заборонені плаваючи елементи
      *right - з правого боку заборонені плаваючи елементи
      *both - плаваючи елементи заборонені з лівого і з правого боку
      *inherit - елемент наслідує clear значення свого предка

*/




_____________________________________________________
/* ! Макет - Властивість display
*Блочні елементи
*Вбудовані рядкові елементи
*display - визначає як має відображатися елемент
Властивості: 
-none
-inline
-block
*visibility:hidden; - визначає чи повинен елемент бути видимим
*max-width - покращує роботу браузера з невеликими вікнами

Кожен HTML-елемент має значення за замовчуванням в залежності від типу елемента.
Значення за замовчуванням для більшості елементів є block або inline.

*Блочні елементи
Блочні елементи завжди починаються з нового рядка й займають всю доступну ширину в право і в ліво
Блочні елементи: 
-<div>
-<h1> - <h6>
-<p>
-<form>
-<header>
-<footer>
-<section>
*Вбудовані рядкові елементи
Не починаються з нового рядка і займають ширини скільки необхідно
Вбудовані елементи: 
-<span>
-<a>
-<img>

  *display: none; - зазвичай використовується в JS для прихованя та відображення елеменів без їх видалення та повторного створення
  Приховання елемента: елемент буде приховано, а сторінка буде відображатись так як би елемента там не було
    h1.hidden {
      display: none;
    }
    <h1>Это видимый заголовок</h1>
    <h1 class="hidden">Это скрытый заголовок</h1> <- не займає місце якщо далі є щє якийсь елемент
  *display: inline; - Перевизначення значення за замовчуванням
  Кожен елемент має значення за замовчуванням. Однак його можна перевизначити. Змінити вбудований елемент на блочний або навпаки
  Приклад: відображає список силок в вигляді горизонтального меню
  <style>li {
      display: inline;
    }
  </style>
  <ul>
    <li><a href="../html/index.html" target="_blank">HTML</a></li>
    <li><a href="../css/index.html" target="_blank">CSS</a></li>
    <li><a href="../js/index.html" target="_blank">JavaScript</a></li>
  </ul>
  Р-тат: HTML CSS JavaScript
  Встановлення властивості відображення елемент змінить лише спосіб відображення елемента, а не те який це елемент.
  Таким чином вбудований елемент з display: block; не може містити інші елементи блоку всередині нього

  *display: block; - приводить до розриву рядка мід 2 елементами
  Приклад: відображення <span> як блочного елемента
    span {
      display: block;
    }
    <span>Свойство display со значением "block" приводит к</span> <span> разрыву строки между двумя элементами.</span>
    
  Приклад: відображення <a> як блочного елемента 
  a {
    display: block;
  }
  <a href="../html/index.html" target="_blank">HTML</a>
  <a href="../css/index.html" target="_blank">CSS</a>
  <a href="../js/index.html" target="_blank">JavaScript</a>
  Р-тат: відображення силок як елементів блока
  HTML
  CSS
  JavaScript

  *visibility:hidden; - приховує елемент, але він буде займати той самий простір.
  Приклад: 
    h1.hidden {
      visibility: hidden;
    }
    
  *Використання CSS разом з JS для відображення контенту
  <head>
<style>
#panel, .flip {
  font-size: 16px;
  padding: 10px;
  text-align: center;
  background-color: #4CAF50;
  color: white;
  border: solid 1px #a6d8a8;
  margin: auto;
}
#panel {
  display: none;
}
</style>
</head>
<body>

<p class="flip" onclick="myFunction()">Кликните, чтобы показать панель</p>

<div id="panel">
  <p>Эта панель содержит элемент div, который по умолчанию скрыт (display: none).</p>
  <p>Он оформлен в стиле CSS, и мы используем JavaScript, чтобы показать его (display: block).</p>
  <p>Как это работает: обратите внимание, что элемент p из class="flip" имеет прикрепленный к нему атрибут onclick. Когда пользователь кликает элемент p, выполняется функция myFunction(), которая меняет стиль div с id="panel" с display: none (hidden) на display: block (visible).</p>
  <p>Вы узнаете больше о JavaScript в учебнике по JavaScript на нашем сайте.</p>
</div>

<script>
function myFunction() {
  document.getElementById("panel").style.display = "block";
}
</script>

</body>       



*max-width - покращує роботу браузера з невеликими вікнами
Блочний елемент завжди розтягується на всю доступну ширину віана браузера.
Але існує проблема з адаптативністю під пристрої з малим екраном. Коли вікно браузера менше ширини елемента і браузер потім додає горизонтальну смугу прокрутки.
  Приклад: 
  Якщо зменшити вікно браузера додасться смуга прокрутки
    div.ex1 {
      width: 500px;
      margin: auto;
      border: 3px solid #73AD21;
    }
  Якщо зменшити вікно браузера елемент компактно і гарненько підлаштується під його ширину використовуючи перенесення рядків
    div.ex2 {
      max-width: 500px;
      margin: auto;
      border: 3px solid #73AD21;
    }     */
    
/* * Position - визначає тип метода позиціонування, що використовується для елемента
Є 5 різних значень: 
*static - статичний
*relative - відносний
*fixed - фіксований
*absolute - абсолютний
*sticky - закріплений
*z-index - визначає порядок стека елемента
*clip - Закріплює абсолютно позиціонований елемент
Потім елементи позиціонуються з використанням властивостей: top, bottom, left, right. Але вони не будуть працювати якщо спочатку не встановлено властивість position. Вони також працюють по-рязному в залежності від значення position


    *position: static; - позиціонується відповідно до звичайного потоку сторінки
    HTML-елементи за замовчуванням розташовані статично. На статичні елементи не впливають властивості top, bottom, left та right.
        div.static {
          position: static;
          border: 3px solid #73AD21;
        }

    *position: relative; - позиціонується відносно свого нормального положення
    Встановлення властивостей top, right, bottom та left відносно позиціонованого елемента призведе до відхилення від його нормального положення. Інший зміст не буде відкоректовано, щоб вписатися в будь-який пробіл, залишений елементом.
        div.relative {
          position: relative;
          left: 30px;
          border: 3px solid #73AD21;
        }

    *position: fixed; - позиціонується відносно області перегляду, що означає що він завжди залишається на тому самому місці навіть якщо сторінка прокручується
    Властивості top, right, bottom та left використовуються для позиціонування елемента. Фіксований (fixed) елемент не залишає пробілу на сторінці, де він, зазвичай, знаходився б.
        div.fixed {
          position: fixed;
          bottom: 0;
          right: 0;
          width: 300px;
          border: 3px solid #73AD21;
        }

    *position: absolute; - позиціонується відносно найближчого позиційного предка(замість позиціонування відносно вікна перегляду, як фіксований )
    Але якщо він не має позиційного предка, він використовує тіло документа і переміщується разом з прокруткою сторінки .
    "Позиціонований" елемент - це той, чия позиція що завгодно, крім static
        div.relative {
          position: relative;
          width: 400px;
          height: 200px;
          border: 3px solid #73AD21;
        }
    
        div.absolute {
          position: absolute;
          top: 80px;
          right: 0;
          width: 200px;
          height: 100px;
          border: 3px solid #73AD21;
        }


    *position: sticky; - позиціонується на основі позиції прокрутки користувача
    Елемент sticky переключається між relative та fixed, в залежності від положення прокрутки. Він позиціонується відносно до тих пір, поки у вікні перегляду не буде досягнута задана позиція зміщення, а потім він закрупиться на місці(наприклад, position:fixed)
    
    ? Примітка:  Internet Explorer, Edge 15 і ранні версії не підтримують position: sticky. Safari вимагає -webkit-prefix.

    Для роботи sticky позиціонування має бути вказано хочяб одне із значень: top, right, bottom або left
    Приклад: sticky елемент дотримується верхньої частини сторінки (top: 0), коли буде досягнуто позиції прокрутки
        div.sticky {
          position: -webkit-sticky;
          position: sticky;
          top: 0;
          padding: 5px;
          background-color: #cae8ca;
          border: 2px solid #4CAF50;
        }
        <div style="padding-bottom:2000px">
        <p>В этом примере липкий элемент прикрепляется к верхней части страницы (вверху: 0), когда вы достигаете его позиции прокрутки.</p>
        <p>Прокрутите назад, чтобы удалить прилипание.</p> */








  /*  *z-index - визначає порядок стека елемента (який елемент має бути розташований попереду або позаду інших, тобто який елемент перекриває інший)
    Коли елемент позиціонується на сторінці, він може перекривати інші елементи.
    Елемент може мати позитивний або негативний порядок в стеку. Елемент з більш високим порядком стека знаходиться попереду елемента з більш низьким порядком стека
    Приклад: Оскільки зображеня має z-index: -1; воно буде розміщено за текстом
        img {
          position: absolute;
          left: 0px;
          top: 0px;
          z-index: -1;
        }
        <img src="../images/w3css.gif" width="100" height="140">
    ? Примітка: Якщо два позиціонні елементи перекриваються без вказування z-index, елемент розташований останнім в HTML буде відображатись зверху

    Приклади: Розміщення тексту поверх зображення
    -Зверху зліва
        .container {
          position: relative;
        }
        .topleft {
          position: absolute;
          top: 8px;
          left: 16px;
          font-size: 18px;
        }
        img {
          width: 100%;
          height: auto;
          opacity: 0.3;
        }
        <div class="container">
  <img src="../images/img_5terre_wide.jpg" alt="Cinque Terre" width="1000" height="300">
  <div class="topleft">Слева вверху</div>
    -Знизу зліва
        .container {
          position: relative;
        }
        .bottomleft {
          position: absolute;
          bottom: 8px;
          left: 16px;
          font-size: 18px;
        }
        img {
          width: 100%;
          height: auto;
          opacity: 0.3;
        }
        <div class="container">
  <img src="../images/img_5terre_wide.jpg" alt="Cinque Terre" width="1000" height="300">
  <div class="bottomleft">Слева внизу</div>
    -Зверху справа
        .container {
          position: relative;
        }

        .topright {
          position: absolute;
          top: 8px;
          right: 16px;
          font-size: 18px;
        }

        img {
          width: 100%;
          height: auto;
          opacity: 0.3;
        }
<div class="container">
  <img src="../images/img_5terre_wide.jpg" alt="Cinque Terre" width="1000" height="300">
  <div class="topright">Справа вверху</div>
  -По центру
    .container {
      position: relative;
    }
    .center {
      position: absolute;
      top: 50%;
      width: 100%;
      text-align: center;
      font-size: 18px;
    }
    img {
      width: 100%;
      height: auto;
      opacity: 0.3;
    }
    <div class="container">
  <img src="../images/img_5terre_wide.jpg" alt="Cinque Terre" width="1000" height="300">
  <div class="center">В центре</div>
  -Встановлення форми елемента. Елемент обрізається до цієї форми та відображається
      img {
        position: absolute;
        clip: rect(0px, 60px, 200px, 0px);
      }
<img src="../images/w3css.gif" width="100" height="140">     */








/*  *  Макет - Overflow - визначає, що відбувається, якщо зміст переповнює поле елемента
Вказує чи слід обрізати вміст або додавати смугу прокрутки, якщо вміст елемента занадто великий, щоб вміститись у вказаній області
Занчення: 
*visible - за замовчуванням. Переповнення не обрізається. Контент відображається поза полем елемента
*hidden - переповнення обрізається(приховується), а інша частина змісту буде невидимою
*scroll - переповнення обрізається, і додається смуга прокрутки, щоб побачити іншу частину змісту
*auto - аналошічно scroll, але додається смуга прокрутки лише при необхідності

? Примітка: властивість Overflow працює лише для блочних елементів із вказаною висотою. В OS X Lion (на Mac) смуга прокрутки за замовчуванянм прихована та відображається лише при використанні

    *overflow: visible
        div {
          background-color: #eee;
          width: 200px;
          height: 50px;
          border: 1px dotted black;
          overflow: visible;
        }

    *overflow: hidden
        div {
          background-color: #eee;
          width: 200px;
          height: 50px;
          border: 1px dotted black;
          overflow: hidden;
        }

    *overflow: scroll
    Смуга прокрутки додається як по горизонталі так і по вертикалі(навіть якщо вона не потрібна)
        div {
          background-color: #eee;
          width: 200px;
          height: 100px;
          border: 1px dotted black;
          overflow: scroll;
        }

    *overflow: auto
        div {
          background-color: #eee;
          width: 200px;
          height: 50px;
          border: 1px dotted black;
          overflow: auto;
        }

    *overflow-x та overflow-y - вказує чи слід змінювати переповнення змісту лише по горизонталі або лише по вертикалі(або обидва варіанта)
        *overflow-x вказує, що робити з лівим/правим краєм змісту, якщо воно виходить за межі області змісту елемента
        *overflow-y вказує, що робити з верхнім/нижнім краєм змісту,якщо воно виходить за межі області змісту елемента
        div {
          overflow-x: hidden;   Сховати горизонтальну смугу прокрутки 
          overflow-y: scroll;   Додати вертикальну смугу прокрутки 
        }         */
















 /*  * Макет - float и clear
 *float - визначає, як елемент має позиціонуватись(плавати) відносно інших елементів
 *clear - визначає, які елементи можуть плавати поруч з очищеним (clear) елементом і з якого боку

    *float - використовується для позиціонування та форматування змісту, коли зображення розташовується зліва від тексту в контейнері
    Значення: 
      *left - Елемент плаває зліва від свого контейнера.
      *right - Елемент плаває справа від свого контейнера.
      *none - Елемент не плаває (буде відображатися саме там, де він зустрічається в тексті). Це за замовчуванням
      *inherit - Елемент наслідує float-значення свого предка
    В найпростішому випадку властвість  float можна використовувати для обтікання текстом зображень
    Приклади: 
    Розташування зображення від тексту справа
        img {
          float: right;
        }
        <img src="../images/pineapple.jpg" alt="Float Right" style="width:170px;height:170px;margin-left:15px;">
    Розташування зображення від тексту зліва
        img {
          float: left;
        }
        <img src="../images/pineapple.jpg" alt="Float Left" style="width:170px;height:170px;margin-right:15px;">
    No float - зображення буде видображатись там де воно зустрічається в тексті (float: none; ):
        img {
          float: none;
        }
        <img src="../images/pineapple.jpg" alt="Float None" style="width:170px;height:170px;">
    Елементи розташовуються поруч один із одним, в прикладі три div будуть розташовані ожин за одним
        div {
          float: left;
          padding: 15px;
        }
    
        .div1 {
          background: red;
        }
    
        .div2 {
          background: yellow;
        }
    
        .div3 {
          background: green;
        }
        <div class="div1">Div 1</div>
        <div class="div2">Div 2</div>
        <div class="div3">Div 3</div>




    *clear - визначає які елементи можуть плавати поруч із очищеним елементом і з якого боку
      Значення: 
      *none - допускає плаваючи елементи з обох боків. Це за замовчуванням
      *left - з лівого боку заборонені плаваючи елементи
      *right - з правого боку заборонені плаваючи елементи
      *both - плаваючи елементи заборонені з лівого і з правого боку
      *inherit - елемент наслідує clear значення свого предка
    
    Найбільш розповсюджений спосіб використання після того, як було застосовано властивість float елемента
    При очищенні float потрібно співставити clear із float: якщо елемент переміщується в ліво, його потрібно очистити. float елемент буде продовжувати плавати, але clear елемент з'явиться під ним на сторінці

    Приклад: очищується float зліва. Це означає що з лівого боку (від div)не допускається плаваючий елемент
        <style>.div1 {
          float: left;
          width: 100px;
          height: 50px;
          margin: 10px;
          border: 3px solid #73AD21;
        }
        .div2 {
          border: 1px solid red;
        }
        .div3 {
          float: left;
          width: 100px;
          height: 50px;
          margin: 10px;
          border: 3px solid #73AD21;
        }
        .div4 {
          border: 1px solid red;
          clear: left;
        }
        </style></head><body><h2>Без clear</h2><div class="div1">div1</div><div class="div2">div2 - Обратите внимание,
        что div2 стоит после div1 в HTML-коде. Однако,
        поскольку div1 перемещается влево,
        текст в div2 обтекает div1.</div><br><br><h2>Из clear</h2><div class="div3">div3</div><div class="div4">div4 - Здесь clear: left;
        перемещает div4 ниже плавающего div3. Значение "left" очищает элементы,
        перемещаемые влево. Вы также можете очистить "right" и "both" .</div>




















 */
































